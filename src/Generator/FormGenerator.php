<?php

namespace MediaWiki\Extension\StructureSync\Generator;

use MediaWiki\Extension\StructureSync\Schema\CategoryModel;
use MediaWiki\Extension\StructureSync\Schema\PropertyModel;
use MediaWiki\Extension\StructureSync\Store\PageCreator;
use MediaWiki\Extension\StructureSync\Store\WikiPropertyStore;

/**
 * FormGenerator
 * -------------
 * Generates PageForms forms from an effective (fully-inherited) CategoryModel.
 *
 * Responsibilities:
 *   - Convert Schema → PageForms form wikitext
 *   - Use explicit form sections if defined in schema
 *   - Otherwise (Option C):
 *       * Main section for current category with required/optional split
 *       * Placeholder sections for ancestors (inherited), ready for manual/schema refinement
 *   - Generate PageForms fields with correct input type + required indicator
 *   - Save forms via PageCreator
 *
 * NOTE:
 *   - This class should receive the effective CategoryModel (after inheritance),
 *     typically produced by InheritanceResolver::getEffectiveCategory().
 *   - $ancestorChain should be the C3-linearized ancestor list including self.
 */
class FormGenerator {

    /** @var PageCreator */
    private $pageCreator;

    /** @var WikiPropertyStore */
    private $propertyStore;

    /** @var PropertyInputMapper */
    private $inputMapper;

    /**
     * @param PageCreator|null $pageCreator
     * @param WikiPropertyStore|null $propertyStore
     * @param PropertyInputMapper|null $inputMapper
     */
    public function __construct(
        PageCreator $pageCreator = null,
        WikiPropertyStore $propertyStore = null,
        PropertyInputMapper $inputMapper = null
    ) {
        $this->pageCreator   = $pageCreator   ?? new PageCreator();
        $this->propertyStore = $propertyStore ?? new WikiPropertyStore();
        $this->inputMapper   = $inputMapper   ?? new PropertyInputMapper();
    }

    /**
     * Generate complete PageForms wikitext for a category.
     *
     * @param CategoryModel $category      Effective (inherited) category
     * @param string[]      $ancestorChain Optional list of ancestor names including self
     *
     * @return string
     */
    public function generateForm( CategoryModel $category, array $ancestorChain = [] ): string {

        $lines = [];

        // ------------------------------------------------------------------
        // NOINCLUDE HEADER
        // ------------------------------------------------------------------
        $lines[] = '<noinclude>';
        $lines[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
        $lines[] = '<!-- This form is automatically regenerated -->';
        $lines[] = 'This is the form for editing [[Category:' . $category->getName() . ']] pages.';
        $lines[] = '</noinclude><includeonly>';
        $lines[] = '';

        // ------------------------------------------------------------------
        // PageForms form info
        // ------------------------------------------------------------------
        $lines[] = '{{{info';
        $lines[] = '|page name=<' . $category->getLabel() . '>';
        $lines[] = '|create title=Create new ' . $category->getLabel();
        $lines[] = '|edit title=Edit ' . $category->getLabel();
        $lines[] = '}}}';
        $lines[] = '';

        // ------------------------------------------------------------------
        // Template binding
        // ------------------------------------------------------------------
        $lines[] = '{{{for template|' . $category->getName() . '}}}';
        $lines[] = '';

        // ------------------------------------------------------------------
        // Determine section strategy
        // ------------------------------------------------------------------
        $formSections = $category->getFormSections();

        if ( !empty( $formSections ) ) {
            // Explicit schema-defined sections
            foreach ( $formSections as $section ) {
                $lines = array_merge(
                    $lines,
                    $this->generateFormSection( $section, $category )
                );
            }
        } else {
            // Option C behavior
            if ( !empty( $ancestorChain ) ) {
                $lines = array_merge(
                    $lines,
                    $this->generateHybridSections( $category, $ancestorChain )
                );
            } else {
                // Simple fallback (no ancestor info)
                $lines = array_merge(
                    $lines,
                    $this->generateSimpleRequiredOptionalSections( $category, 3 )
                );
            }
        }

        // ------------------------------------------------------------------
        // End template + page operations
        // ------------------------------------------------------------------
        $lines[] = '{{{end template}}}';
        $lines[] = '';
        $lines[] = '{{{standard input|summary}}}';
        $lines[] = '';
        $lines[] = '{{{standard input|save}}} '
                 . '{{{standard input|preview}}} '
                 . '{{{standard input|changes}}} '
                 . '{{{standard input|cancel}}}';
        $lines[] = '</includeonly>';

        return implode( "\n", $lines );
    }

    /**
     * Generate a section based on explicit config from the schema.
     *
     * @param array        $section  Must include: [ 'name' => string, 'properties' => string[] ]
     * @param CategoryModel $category
     * @return array
     */
    private function generateFormSection( array $section, CategoryModel $category ): array {

        $lines = [];

        $name       = $section['name'] ?? 'Section';
        $properties = $section['properties'] ?? [];

        $lines[] = "=== $name ===";
        $lines[] = '';

        foreach ( $properties as $propertyName ) {
            $lines = array_merge(
                $lines,
                $this->generateFieldDefinition( (string)$propertyName, $category )
            );
        }

        $lines[] = '';
        return $lines;
    }

    /**
     * Option C hybrid behavior:
     *   - Primary section for the current category with required/optional fields.
     *   - Placeholder sections for each ancestor (inherited) for future refinement.
     *
     * @param CategoryModel $category
     * @param string[]      $ancestorChain
     * @return array
     */
    private function generateHybridSections( CategoryModel $category, array $ancestorChain ): array {

        $lines = [];

        // Normalize chain: ensure it includes this category name (should be first)
        $selfName = $category->getName();
        if ( empty( $ancestorChain ) || reset( $ancestorChain ) !== $selfName ) {
            array_unshift( $ancestorChain, $selfName );
        }

        // 1) Main section for this category
        $lines[] = '=== ' . $category->getLabel() . ' ===';
        $lines[] = '';

        $lines = array_merge(
            $lines,
            $this->generateSimpleRequiredOptionalSections( $category, 4 )
        );

        // 2) Sections for each ancestor (excluding this category)
        $ancestorsOnly = array_filter(
            $ancestorChain,
            static function ( $name ) use ( $selfName ) {
                return $name !== $selfName;
            }
        );

        foreach ( $ancestorsOnly as $ancestorName ) {
            // Placeholder section; no fields, but clearly indicates inheritance.
            $lines[] = '=== ' . $ancestorName . ' (inherited) ===';
            $lines[] = '<!-- This category inherits structural properties from [[' . $ancestorName . ']]. -->';
            $lines[] = '<!-- Customize form sections for this ancestor via StructureSync schema (forms.display/forms.config). -->';
            $lines[] = '';
        }

        return $lines;
    }

    /**
     * Generate required/optional field blocks with a given heading level.
     *
     * @param CategoryModel $category
     * @param int           $headingLevel 3 → "===", 4 → "===="
     * @return array
     */
    private function generateSimpleRequiredOptionalSections( CategoryModel $category, int $headingLevel ): array {

        $lines = [];

        $prefix = str_repeat( '=', $headingLevel );
        $required = $category->getRequiredProperties();
        $optional = $category->getOptionalProperties();

        // Deterministic ordering
        sort( $required );
        sort( $optional );

        if ( !empty( $required ) ) {
            $lines[] = "{$prefix} Required Information {$prefix}";
            $lines[] = '';
            foreach ( $required as $prop ) {
                $lines = array_merge(
                    $lines,
                    $this->generateFieldDefinition( $prop, $category )
                );
            }
            $lines[] = '';
        }

        if ( !empty( $optional ) ) {
            $lines[] = "{$prefix} Additional Information {$prefix}";
            $lines[] = '';
            foreach ( $optional as $prop ) {
                $lines = array_merge(
                    $lines,
                    $this->generateFieldDefinition( $prop, $category )
                );
            }
            $lines[] = '';
        }

        return $lines;
    }

    /**
     * Generate field definition for a specific property.
     *
     * @param string        $propertyName
     * @param CategoryModel $category  Effective category model
     * @return array
     */
    private function generateFieldDefinition(
        string $propertyName,
        CategoryModel $category
    ): array {

        $lines = [];

        // Lookup property metadata; fallback to simple Text property
        $property = $this->propertyStore->readProperty( $propertyName )
            ?: new PropertyModel( $propertyName, [ 'datatype' => 'Text' ] );

        $isRequired = $category->isPropertyRequired( $propertyName );

        // Label
        $label = $property->getLabel();
        $lines[] = "'''" . $label . ":'''";

        // Input definition
        $inputDefinition = $this->inputMapper->generateInputDefinition(
            $property,
            $isRequired
        );

        $param = $this->propertyToParameter( $propertyName );

        $lines[] = '{{{field|' . $param . '|' . $inputDefinition . '}}}';
        $lines[] = '';

        return $lines;
    }

    /**
     * Convert property name → safe PageForms parameter name.
     *
     * Rules (aligned with TemplateGenerator & DisplayStubGenerator):
     *   - Remove leading "Has "
     *   - Replace ":" with "_"
     *   - Lowercase
     *   - Spaces → underscores
     *
     * @param string $propertyName
     * @return string
     */
    private function propertyToParameter( string $propertyName ): string {

        $param = $propertyName;

        if ( str_starts_with( $param, 'Has ' ) ) {
            $param = substr( $param, 4 );
        }

        $param = str_replace( ':', '_', $param );
        $param = strtolower( trim( $param ) );
        $param = str_replace( ' ', '_', $param );

        return $param;
    }

    /**
     * Update or create the corresponding Form: page.
     *
     * @param string $formName
     * @param string $content
     * @return bool
     */
    public function updateForm( string $formName, string $content ): bool {

        $title = $this->pageCreator->makeTitle( $formName, PF_NS_FORM );
        if ( $title === null ) {
            return false;
        }

        $summary = 'StructureSync: Auto-generated form';
        return $this->pageCreator->createOrUpdatePage( $title, $content, $summary );
    }

    /**
     * Convenience wrapper to generate + save a form.
     *
     * @param CategoryModel $category
     * @param string[]      $ancestorChain
     * @return bool
     */
    public function generateAndSaveForm(
        CategoryModel $category,
        array $ancestorChain = []
    ): bool {

        $wikitext = $this->generateForm( $category, $ancestorChain );
        return $this->updateForm( $category->getName(), $wikitext );
    }

    /**
     * Determine whether a form exists for a category.
     *
     * @param string $categoryName
     * @return bool
     */
    public function formExists( string $categoryName ): bool {

        $title = $this->pageCreator->makeTitle( $categoryName, PF_NS_FORM );
        return $title && $this->pageCreator->pageExists( $title );
    }
}
