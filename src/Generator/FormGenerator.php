<?php

namespace MediaWiki\Extension\StructureSync\Generator;

use MediaWiki\Extension\StructureSync\Schema\CategoryModel;
use MediaWiki\Extension\StructureSync\Schema\PropertyModel;
use MediaWiki\Extension\StructureSync\Store\PageCreator;
use MediaWiki\Extension\StructureSync\Store\WikiPropertyStore;
use MediaWiki\Extension\StructureSync\Util\NamingHelper;

/**
 * FormGenerator
 * -------------
 * Generates PageForms forms from an effective (fully-inherited) CategoryModel.
 *
 * Responsibilities:
 *   - Convert Schema → PageForms form wikitext
 *   - Use explicit form sections if defined in schema
 *   - Otherwise (Option C):
 *       * Main section for current category with required/optional split
 *       * Placeholder sections for ancestors (inherited), ready for manual/schema refinement
 *   - Generate PageForms fields with correct input type + required indicator
 *   - Save forms via PageCreator
 *
 * NOTE:
 *   - This class should receive the effective CategoryModel (after inheritance),
 *     typically produced by InheritanceResolver::getEffectiveCategory().
 *   - $ancestorChain should be the C3-linearized ancestor list including self.
 */
class FormGenerator {
    
    /** @var int Heading level for top-level sections (===) */
    private const HEADING_LEVEL_TOP = 3;
    
    /** @var int Heading level for subsections (====) */
    private const HEADING_LEVEL_SUB = 4;

    /** @var PageCreator */
    private $pageCreator;

    /** @var WikiPropertyStore */
    private $propertyStore;

    /** @var PropertyInputMapper */
    private $inputMapper;

    /**
     * @param PageCreator|null $pageCreator
     * @param WikiPropertyStore|null $propertyStore
     * @param PropertyInputMapper|null $inputMapper
     */
    public function __construct(
        PageCreator $pageCreator = null,
        WikiPropertyStore $propertyStore = null,
        PropertyInputMapper $inputMapper = null
    ) {
        $this->pageCreator   = $pageCreator   ?? new PageCreator();
        $this->propertyStore = $propertyStore ?? new WikiPropertyStore();
        $this->inputMapper   = $inputMapper   ?? new PropertyInputMapper();
    }

    /**
     * Sanitize a value to ensure MediaWiki never encounters null.
     *
     * @param string|null $value
     * @return string
     */
    private function sanitize( ?string $value ): string {
        return $value ?? '';
    }

    /**
     * Generate complete PageForms wikitext for a category.
     *
     * @param CategoryModel $category      Effective (inherited) category
     * @param string[]      $ancestorChain Optional list of ancestor names including self
     *
     * @return string PageForms wikitext
     * @throws \InvalidArgumentException If category name is empty
     */
    public function generateForm( CategoryModel $category, array $ancestorChain = [] ): string {
        
        if (trim($category->getName()) === '') {
            throw new \InvalidArgumentException('Category name cannot be empty');
        }
        
        if (trim($category->getLabel()) === '') {
            throw new \InvalidArgumentException('Category label cannot be empty');
        }

        $lines = [];

        // ------------------------------------------------------------------
        // NOINCLUDE HEADER
        // ------------------------------------------------------------------
        $categoryName = $this->sanitize( $category->getName() );
        $lines[] = '<noinclude>';
        $lines[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
        $lines[] = '<!-- This form is automatically regenerated -->';
        $lines[] = 'This is the form for editing [[:Category:' . $categoryName . ']] pages.';
        $lines[] = '{{#forminput:form=' . $categoryName . '|autocomplete on category=' . $categoryName . '}}';
        $lines[] = '</noinclude><includeonly>';
        $lines[] = '';

        // ------------------------------------------------------------------
        // PageForms form info
        // ------------------------------------------------------------------
        $lines[] = '{{{info';
        
        // If category has a target namespace, use the format <Namespace:{{{label}}}>
        // Otherwise use the simple format <Label>
        if ( $category->getTargetNamespace() !== null ) {
            $pageName = '<' . $this->sanitize( $category->getTargetNamespace() ) . ':{{{label}}}>';
        } else {
            $pageName = '<' . $this->sanitize( $category->getLabel() ) . '>';
        }
        $lines[] = '|page name=' . $pageName;
        
        $lines[] = '|create title=Create new ' . $this->sanitize( $category->getLabel() );
        $lines[] = '|edit title=Edit ' . $this->sanitize( $category->getLabel() );
        $lines[] = '}}}';
        $lines[] = '';

        // ------------------------------------------------------------------
        // Template binding
        // ------------------------------------------------------------------
        $lines[] = '{{{for template|' . $this->sanitize( $category->getName() ) . '}}}';
        $lines[] = '';

        // ------------------------------------------------------------------
        // Determine section strategy
        // ------------------------------------------------------------------
        $formSections = $category->getFormSections();

        if ( !empty( $formSections ) ) {
            // Explicit schema-defined sections
            foreach ( $formSections as $section ) {
                $lines = array_merge(
                    $lines,
                    $this->generateFormSection( $section, $category )
                );
            }
        } else {
            // Option C behavior
            if ( !empty( $ancestorChain ) ) {
                $lines = array_merge(
                    $lines,
                    $this->generateHybridSections( $category, $ancestorChain )
                );
            } else {
                // Simple fallback (no ancestor info)
                $lines = array_merge(
                    $lines,
                    $this->generateSimpleRequiredOptionalSections( $category, self::HEADING_LEVEL_TOP )
                );
            }
        }

        // ------------------------------------------------------------------
        // End template + page operations
        // ------------------------------------------------------------------
        $lines[] = '{{{end template}}}';
        $lines[] = '';
        $lines[] = '{{{standard input|summary}}}';
        $lines[] = '';
        $lines[] = '{{{standard input|save}}} '
                 . '{{{standard input|preview}}} '
                 . '{{{standard input|changes}}} '
                 . '{{{standard input|cancel}}}';
        $lines[] = '</includeonly>';

        return implode( "\n", $lines );
    }

    /**
     * Generate a section based on explicit config from the schema.
     *
     * @param array        $section  Must include: [ 'name' => string, 'properties' => string[] ]
     * @param CategoryModel $category
     * @return array
     */
    private function generateFormSection( array $section, CategoryModel $category ): array {

        $lines = [];

        $name       = $this->sanitize( $section['name'] ?? 'Section' );
        $properties = $section['properties'] ?? [];

        $lines[] = '=== ' . $name . ' ===';
        $lines[] = '';

        foreach ( $properties as $propertyName ) {
            $lines = array_merge(
                $lines,
                $this->generateFieldDefinition( (string)$propertyName, $category )
            );
        }

        $lines[] = '';
        return $lines;
    }

    /**
     * Option C hybrid behavior:
     *   - Primary section for the current category with required/optional fields.
     *   - Placeholder sections for each ancestor (inherited) for future refinement.
     *
     * @param CategoryModel $category
     * @param string[]      $ancestorChain
     * @return array
     */
    private function generateHybridSections( CategoryModel $category, array $ancestorChain ): array {

        $lines = [];

        // Normalize chain: ensure it includes this category name (should be first)
        $selfName = $category->getName();
        if ( empty( $ancestorChain ) || reset( $ancestorChain ) !== $selfName ) {
            array_unshift( $ancestorChain, $selfName );
        }

        // 1) Main section for this category
        $lines[] = '=== ' . $this->sanitize( $category->getLabel() ) . ' ===';
        $lines[] = '';

        $lines = array_merge(
            $lines,
            $this->generateSimpleRequiredOptionalSections( $category, self::HEADING_LEVEL_SUB )
        );

        // 2) Sections for each ancestor (excluding this category)
        $ancestorsOnly = array_filter(
            $ancestorChain,
            static function ( $name ) use ( $selfName ) {
                return $name !== $selfName;
            }
        );

        foreach ( $ancestorsOnly as $ancestorName ) {
            // Placeholder section; no fields, but clearly indicates inheritance.
            $ancestorNameSafe = $this->sanitize( $ancestorName );
            $lines[] = '=== ' . $ancestorNameSafe . ' (inherited) ===';
            $lines[] = '<!-- This category inherits structural properties from [[' . $ancestorNameSafe . ']]. -->';
            $lines[] = '<!-- Customize form sections for this ancestor via StructureSync schema (forms.display/forms.config). -->';
            $lines[] = '';
        }

        return $lines;
    }

    /**
     * Generate required/optional field blocks with a given heading level.
     *
     * @param CategoryModel $category
     * @param int           $headingLevel 3 → "===", 4 → "===="
     * @return array
     */
    private function generateSimpleRequiredOptionalSections( CategoryModel $category, int $headingLevel ): array {

        $lines = [];

        $prefix = str_repeat( '=', $headingLevel );
        $required = $category->getRequiredProperties();
        $optional = $category->getOptionalProperties();

        // Deterministic ordering
        sort( $required );
        sort( $optional );

        if ( !empty( $required ) ) {
            $lines[] = "{$prefix} Required Information {$prefix}";
            $lines[] = '';
            foreach ( $required as $prop ) {
                $lines = array_merge(
                    $lines,
                    $this->generateFieldDefinition( $prop, $category )
                );
            }
            $lines[] = '';
        }

        if ( !empty( $optional ) ) {
            $lines[] = "{$prefix} Additional Information {$prefix}";
            $lines[] = '';
            foreach ( $optional as $prop ) {
                $lines = array_merge(
                    $lines,
                    $this->generateFieldDefinition( $prop, $category )
                );
            }
            $lines[] = '';
        }

        return $lines;
    }

    /**
     * Generate field definition for a specific property.
     *
     * @param string        $propertyName
     * @param CategoryModel $category  Effective category model
     * @return array
     */
    private function generateFieldDefinition(
        string $propertyName,
        CategoryModel $category
    ): array {

        $lines = [];

        // Lookup property metadata; fallback to simple Text property
        $property = $this->propertyStore->readProperty( $propertyName )
            ?: new PropertyModel( $propertyName, [ 'datatype' => 'Text' ] );

        $isRequired = $category->isPropertyRequired( $propertyName );

        // Input definition
        $inputDefinition = $this->inputMapper->generateInputDefinition(
            $property,
            $isRequired
        );

        // Get template parameter name and property info
        $param = $this->propertyToParameter( $propertyName );
        $propertyNameSafe = $this->sanitize( $property->getName() );
        $label = $this->sanitize( $property->getLabel() );

        // Display label above the field
        $lines[] = "'''" . $label . ":'''";

        // PageForms field syntax: {{{field|param_name|property=PropertyName|input type=...}}}
        // Note: property= maps to SMW property, and PageForms will use the property's Display label automatically
        $lines[] = '{{{field|' . $this->sanitize( $param ) . '|property=' . $propertyNameSafe . '|' . $this->sanitize( $inputDefinition ) . '}}}';
        $lines[] = '';

        return $lines;
    }

    /**
     * Convert property name → safe PageForms parameter name.
     * 
     * Delegates to NamingHelper for consistent transformation across all generators.
     *
     * @param string $propertyName SMW property name
     * @return string Normalized parameter name for PageForms
     */
    private function propertyToParameter( string $propertyName ): string {
        $param = NamingHelper::propertyToParameter($propertyName);
        
        // Ensure parameter name is never empty (fallback)
        if ( empty( $param ) ) {
            $param = 'value';
        }

        return $param;
    }

    /**
     * Update or create the corresponding Form: page.
     *
     * @param string $formName Form name (without namespace)
     * @param string $content Form wikitext content
     * @return bool True on success, false on failure
     * @throws \InvalidArgumentException If form name is empty
     */
    public function updateForm( string $formName, string $content ): bool {
        
        if (trim($formName) === '') {
            throw new \InvalidArgumentException('Form name cannot be empty');
        }

        $title = $this->pageCreator->makeTitle( $formName, PF_NS_FORM );
        if ( $title === null ) {
            wfLogWarning("StructureSync: Failed to create Title for form '$formName'");
            return false;
        }

        $summary = 'StructureSync: Auto-generated form';
        $result = $this->pageCreator->createOrUpdatePage( $title, $content, $summary );
        
        if (!$result) {
            wfLogWarning("StructureSync: Failed to save form '$formName'");
        }
        
        return $result;
    }

    /**
     * Convenience wrapper to generate + save a form.
     * 
     * This combines form generation and page creation into a single operation.
     *
     * @param CategoryModel $category Effective (inherited) category
     * @param string[]      $ancestorChain Optional list of ancestor names
     * @return bool True on success, false on failure
     * @throws \InvalidArgumentException If category name/label is invalid
     */
    public function generateAndSaveForm(
        CategoryModel $category,
        array $ancestorChain = []
    ): bool {

        try {
            $wikitext = $this->generateForm( $category, $ancestorChain );
            return $this->updateForm( $category->getName(), $wikitext );
        } catch (\Exception $e) {
            wfLogWarning("StructureSync: Failed to generate/save form for '{$category->getName()}': " . $e->getMessage());
            return false;
        }
    }

    /**
     * Determine whether a form exists for a category.
     *
     * @param string $categoryName
     * @return bool
     */
    public function formExists( string $categoryName ): bool {

        $title = $this->pageCreator->makeTitle( $categoryName, PF_NS_FORM );
        return $title && $this->pageCreator->pageExists( $title );
    }
}
