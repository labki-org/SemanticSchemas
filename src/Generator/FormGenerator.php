<?php

namespace MediaWiki\Extension\StructureSync\Generator;

use MediaWiki\Extension\StructureSync\Schema\CategoryModel;
use MediaWiki\Extension\StructureSync\Schema\PropertyModel;
use MediaWiki\Extension\StructureSync\Schema\SubobjectModel;
use MediaWiki\Extension\StructureSync\Store\PageCreator;
use MediaWiki\Extension\StructureSync\Store\WikiPropertyStore;
use MediaWiki\Extension\StructureSync\Store\WikiSubobjectStore;
use MediaWiki\Extension\StructureSync\Util\NamingHelper;

/**
 * FormGenerator (Rewritten 2025)
 * ------------------------------
 *
 * Clean form generator that converts a CategoryModel (already fully inherited)
 * into deterministic PageForms markup.
 *
 * Key changes:
 *  - No inheritance placeholder sections.
 *  - Subobjects use the new namespace-like convention:
 *        Template:Subobject/<Name>
 *  - Category dispatcher template assumed to be Template:<CategoryName>.
 *  - Required/optional property lists rendered simply.
 *  - No PageForms {{{info}}} block (prevents literal rendering issues).
 *  - Optional target namespace supported.
 *  - No hierarchy preview injection; decoupled from JS.
 */
class FormGenerator {

    private PageCreator $pageCreator;
    private WikiPropertyStore $propertyStore;
    private PropertyInputMapper $inputMapper;
    private WikiSubobjectStore $subobjectStore;

    public function __construct(
        PageCreator $pageCreator = null,
        WikiPropertyStore $propertyStore = null,
        PropertyInputMapper $inputMapper = null,
        WikiSubobjectStore $subobjectStore = null
    ) {
        $this->pageCreator    = $pageCreator    ?? new PageCreator();
        $this->propertyStore  = $propertyStore  ?? new WikiPropertyStore();
        $this->inputMapper    = $inputMapper    ?? new PropertyInputMapper();
        $this->subobjectStore = $subobjectStore ?? new WikiSubobjectStore();
    }

    private function s( ?string $v ): string {
        return $v ?? '';
    }

    /**
     * Generate the full PageForms form for a category.
     */
    public function generateForm( CategoryModel $category ): string {

        $name  = trim( $category->getName() );
        $label = trim( $category->getLabel() );

        if ( $name === '' ) {
            throw new \InvalidArgumentException("Category name cannot be empty");
        }
        if ( $label === '' ) {
            throw new \InvalidArgumentException("Category label cannot be empty");
        }

        $lines = [];

        /* ----------------------------------------------------------
         * <noinclude> header
         * -------------------------------------------------------- */
        $lines[] = '<noinclude>';
        $lines[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
        $lines[] = '<!-- This form is automatically regenerated -->';
        $lines[] = 'This is the form for editing [[:Category:' . $this->s($name) . ']] pages.';

        $formInput = [
            'form=' . $this->s($name),
            'autocomplete on category=' . $this->s($name),
        ];

        if ( $category->getTargetNamespace() !== null ) {
            $formInput[] = 'namespace=' . $this->s( $category->getTargetNamespace() );
        }

        $lines[] = '{{#forminput:' . implode('|', $formInput) . '}}';
        $lines[] = '</noinclude><includeonly>';
        $lines[] = '';

        /* ----------------------------------------------------------
         * Bind to dispatcher template
         * -------------------------------------------------------- */
        $lines[] = '{{{for template|' . $this->s($name) . '}}}';
        $lines[] = '';

        /* ----------------------------------------------------------
         * Required + Optional properties
         * -------------------------------------------------------- */
        $lines = array_merge(
            $lines,
            $this->generatePropertySections( $category )
        );

        $lines[] = '{{{end template}}}';
        $lines[] = '';

        /* ----------------------------------------------------------
         * Subobject sections
         * -------------------------------------------------------- */
        $sub = $this->generateSubobjectSections( $category );
        $lines = array_merge( $lines, $sub );

        /* ----------------------------------------------------------
         * Summary + Buttons
         * -------------------------------------------------------- */
        $lines[] = '{{{standard input|summary}}}';
        $lines[] = '';
        $lines[] = '{{{standard input|save}}} '
                 . '{{{standard input|preview}}} '
                 . '{{{standard input|changes}}} '
                 . '{{{standard input|cancel}}}';
        $lines[] = '</includeonly>';

        return implode("\n", $lines);
    }

    /**
     * Required + optional properties
     */
    private function generatePropertySections( CategoryModel $category ): array {
        $required = $category->getRequiredProperties();
        $optional = $category->getOptionalProperties();

        sort( $required );
        sort( $optional );

        $out = [];

        if ( !empty($required) ) {
            $out[] = '=== Required Information ===';
            $out[] = '';
            foreach ( $required as $p ) {
                $out = array_merge(
                    $out,
                    $this->generateField( $p, $category, true )
                );
            }
            $out[] = '';
        }

        if ( !empty($optional) ) {
            $out[] = '=== Optional Information ===';
            $out[] = '';
            foreach ( $optional as $p ) {
                $out = array_merge(
                    $out,
                    $this->generateField( $p, $category, false )
                );
            }
            $out[] = '';
        }

        return $out;
    }

    /**
     * Single PageForms field block
     */
    private function generateField(
        string $propertyName,
        CategoryModel $category,
        ?bool $isRequired = null
    ): array {

        $prop = $this->propertyStore->readProperty( $propertyName )
            ?: new PropertyModel( $propertyName, [ 'datatype' => 'Text' ] );

        $isReq = $isRequired ?? $category->isPropertyRequired( $propertyName );

        $input = $this->inputMapper->generateInputDefinition( $prop, $isReq );
        $param = NamingHelper::propertyToParameter( $propertyName );

        $label = $this->s( $prop->getLabel() );
        $safeProp = $this->s( $prop->getName() );

        return [
            "'''{$label}:'''",
            '{{{field|' . $param . '|property=' . $safeProp . '|' . $input . '}}}',
            ''
        ];
    }

    /**
     * Subobject (repeatable block) sections
     */
    private function generateSubobjectSections( CategoryModel $category ): array {

        $required = $category->getRequiredSubgroups();
        $optional = $category->getOptionalSubgroups();

        $all = [];
        foreach ( $required as $n ) { $all[$n] = true; }
        foreach ( $optional as $n ) {
            if (!isset($all[$n])) {
                $all[$n] = false;
            }
        }

        if ( empty($all) ) {
            return [];
        }

        $out = [];

        foreach ( $all as $subName => $isRequired ) {

            $model = $this->subobjectStore->readSubobject( $subName );
            if ( !$model instanceof SubobjectModel ) {
                wfLogWarning("StructureSync: Missing Subobject:$subName in form gen");
                continue;
            }

            $label = $this->s( $model->getLabel() ?: $model->getName() );

            $out[] = '=== ' . $label . ' ===';
            $out[] = '';

            /* New convention:
             * Subobject templates live at:
             *
             *     Template:Subobject/<SubobjectName>
             */
            $templateName = 'Subobject/' . $this->s( $model->getName() );

            $for = [
                $templateName,
                'multiple',
            ];

            if ( $isRequired ) {
                $for[] = 'minimum instances=1';
            }

            $out[] = '{{{for template|' . implode('|', $for) . '}}}';

            /* Render fields */
            $props = array_merge(
                $model->getRequiredProperties(),
                $model->getOptionalProperties()
            );

            foreach ( $props as $p ) {
                $must = $model->isPropertyRequired( $p );
                $out = array_merge(
                    $out,
                    $this->generateField( $p, $category, $must )
                );
            }

            $out[] = '{{{end template}}}';
            $out[] = '';
        }

        return $out;
    }

    /**
     * Save form page.
     */
    public function updateForm( string $name, string $content ): bool {

        if ( trim($name) === '' ) {
            throw new \InvalidArgumentException("Form name cannot be empty");
        }

        $title = $this->pageCreator->makeTitle( $name, \PF_NS_FORM );
        if ( !$title ) {
            wfLogWarning("StructureSync: Unable to create form title for '$name'");
            return false;
        }

        return $this->pageCreator->createOrUpdatePage(
            $title,
            $content,
            'StructureSync: Auto-generated form'
        );
    }

    public function generateAndSaveForm( CategoryModel $category ): bool {
        try {
            $txt = $this->generateForm( $category );
            return $this->updateForm( $category->getName(), $txt );
        } catch ( \Exception $e ) {
            wfLogWarning(
                "StructureSync: Failed to gen/save form for {$category->getName()}: " .
                $e->getMessage()
            );
            return false;
        }
    }

    public function formExists( string $categoryName ): bool {
        $t = $this->pageCreator->makeTitle( $categoryName, \PF_NS_FORM );
        return $t && $this->pageCreator->pageExists( $t );
    }
}
