<?php

namespace MediaWiki\Extension\SemanticSchemas\Generator;

use MediaWiki\Extension\SemanticSchemas\Schema\CategoryModel;
use MediaWiki\Extension\SemanticSchemas\Schema\PropertyModel;
use MediaWiki\Extension\SemanticSchemas\Schema\SubobjectModel;
use MediaWiki\Extension\SemanticSchemas\Store\PageCreator;
use MediaWiki\Extension\SemanticSchemas\Store\WikiPropertyStore;
use MediaWiki\Extension\SemanticSchemas\Store\WikiSubobjectStore;
use MediaWiki\Extension\SemanticSchemas\Util\NamingHelper;

/**
 * FormGenerator
 * --------------
 * Generates PageForms markup for category creation/editing forms.
 *
 * Features:
 * - Automatic field generation from CategoryModel schema
 * - Required and optional property sections
 * - Subobject repeatable blocks with minimum instances
 * - Namespace support for page creation
 * - Automatic hierarchy preview (when parent category property detected)
 */
class FormGenerator {

	private PageCreator $pageCreator;
	private WikiPropertyStore $propertyStore;
	private PropertyInputMapper $inputMapper;
	private WikiSubobjectStore $subobjectStore;

	public function __construct(
		?PageCreator $pageCreator = null,
		?WikiPropertyStore $propertyStore = null,
		?PropertyInputMapper $inputMapper = null,
		?WikiSubobjectStore $subobjectStore = null
	) {
		$this->pageCreator = $pageCreator ?? new PageCreator();
		$this->propertyStore = $propertyStore ?? new WikiPropertyStore();
		$this->inputMapper = $inputMapper ?? new PropertyInputMapper();
		$this->subobjectStore = $subobjectStore ?? new WikiSubobjectStore();
	}

	private function s( ?string $v ): string {
		return $v ?? '';
	}

	/**
	 * Generate the full PageForms form for a category.
	 */
	public function generateForm( CategoryModel $category ): string {
		$name = trim( $category->getName() );
		$label = trim( $category->getLabel() );

		if ( $name === '' ) {
			throw new \InvalidArgumentException( "Category name cannot be empty" );
		}
		if ( $label === '' ) {
			throw new \InvalidArgumentException( "Category label cannot be empty" );
		}

		$lines = [];

		/* ----------------------------------------------------------
		 * <noinclude> Header
		 * -------------------------------------------------------- */
		$lines[] = '<noinclude>';
		$lines[] = '<!-- AUTO-GENERATED by SemanticSchemas - DO NOT EDIT MANUALLY -->';
		$lines[] = '<!-- This form is automatically regenerated -->';
		$lines[] = 'This is the form for editing [[:Category:' . $this->s( $name ) . ']] pages.';

		$formInput = [
			'form=' . $this->s( $name ),
			'autocomplete on category=' . $this->s( $name ),
		];

		if ( $category->getTargetNamespace() !== null ) {
			$formInput[] = 'namespace=' . $this->s( $category->getTargetNamespace() );
		}

		$lines[] = '{{#forminput:' . implode( '|', $formInput ) . '}}';

		$lines[] = '</noinclude><includeonly>';
		$lines[] = '';

		/* ----------------------------------------------------------
		 * Page name info (for namespace targeting)
		 * -------------------------------------------------------- */
		if ( $category->getTargetNamespace() !== null ) {
			// PageForms requires {{{info|page name=Namespace:<page name>}}} to create
			// pages in a specific namespace. The <page name> placeholder is filled by
			// PageForms with the user-entered page name.
			$lines[] = '{{{info|page name=' . $this->s( $category->getTargetNamespace() ) . ':<page name>}}}';
			$lines[] = '';
		}

		/* ----------------------------------------------------------
		 * Template binding
		 * -------------------------------------------------------- */
		$lines[] = '{{{for template|' . $this->s( $name ) . '}}}';
		$lines[] = '';

		/* ----------------------------------------------------------
		 * Property fields in table format
		 * -------------------------------------------------------- */
		$lines = array_merge( $lines, $this->generatePropertyTable( $category ) );

		$lines[] = '{{{end template}}}';
		$lines[] = '';

		/* ----------------------------------------------------------
		 * Hierarchy Preview (if parent category property exists)
		 * -------------------------------------------------------- */
		$parentProp = $this->findParentCategoryProperty( $category );
		if ( $parentProp !== null ) {
			$lines[] = '{{#semanticschemas_load_form_preview:}}';
			$lines[] = '';

			$parentParam = NamingHelper::propertyToParameter( $parentProp );

			$lines[] = '<!-- Auto-populated category membership field -->';
			$lines[] = '{{{standard input|free text|hidden|rows=1'
				. '|placeholder=Parent categories will be added automatically|id=ss-parent-categories}}}';
			$lines[] = '';

			$lines[] = "'''Hierarchy Preview:'''";
			$lines[] = '<div id="ss-form-hierarchy-preview" data-parent-field="'
				. $this->s( $parentParam ) . '"></div>';
			$lines[] = '';
		}

		/* ----------------------------------------------------------
		 * Subobject sections
		 * -------------------------------------------------------- */
		$lines = array_merge( $lines, $this->generateSubobjectSections( $category ) );

		/* ----------------------------------------------------------
		 * Free text section
		 * -------------------------------------------------------- */
		$lines[] = "'''Free text:'''";
		$lines[] = '';
		$lines[] = '{{{standard input|free text|rows=10}}}';
		$lines[] = '';

		/* ----------------------------------------------------------
		 * Summary + Buttons
		 * -------------------------------------------------------- */
		$lines[] = '{{{standard input|summary}}}';
		$lines[] = '';
		$lines[] = '{{{standard input|save}}} '
			. '{{{standard input|preview}}} '
			. '{{{standard input|changes}}} '
			. '{{{standard input|cancel}}}';
		$lines[] = '</includeonly>';

		return implode( "\n", $lines );
	}

	/**
	 * Generate property fields in a table format.
	 * Separates required and optional properties into distinct sections.
	 */
	private function generatePropertyTable( CategoryModel $category ): array {
		$required = array_unique( $category->getRequiredProperties() );
		$optional = array_unique( $category->getOptionalProperties() );
		sort( $required );
		sort( $optional );

		$out = [];
		$out = array_merge( $out, $this->generatePropertySection( $required, 'Required fields', $category, true ) );
		$out = array_merge( $out, $this->generatePropertySection( $optional, 'Optional fields', $category, false ) );

		return $out;
	}

	/**
	 * Generate a property section with label and table.
	 *
	 * @param array $props List of property names
	 * @param string $label Section label
	 * @param CategoryModel $category The category model
	 * @param bool $isRequired Whether properties in this section are required
	 * @return array Lines of wikitext
	 */
	private function generatePropertySection(
		array $props,
		string $label,
		CategoryModel $category,
		bool $isRequired
	): array {
		if ( empty( $props ) ) {
			return [];
		}

		$out = [];
		$out[] = "'''" . $label . ":'''";
		$out[] = '';
		$out[] = '{| class="formtable"';

		foreach ( $props as $prop ) {
			$out = array_merge( $out, $this->generateTableField( $prop, $category, $isRequired ) );
		}

		$out[] = '|}';
		$out[] = '';

		return $out;
	}

	/**
	 * Generate a table row for a property field with label and description.
	 */
	private function generateTableField(
		string $propertyName,
		CategoryModel $category,
		?bool $isRequired = null
	): array {
		$prop = $this->propertyStore->readProperty( $propertyName )
			?: new PropertyModel( $propertyName, [ 'datatype' => 'Page' ] );

		$isReq = ( $isRequired !== null )
			? $isRequired
			: in_array( $propertyName, $category->getRequiredProperties(), true );

		$param = NamingHelper::propertyToParameter( $propertyName );
		$label = $this->s( $prop->getLabel() );
		$description = $this->s( $prop->getDescription() );

		// Special handling for "Has Type" property
		if ( strcasecmp( $propertyName, 'Has type' ) === 0 ) {
			$input = $this->generateHasTypeInput( $isReq );
		} else {
			$input = $this->inputMapper->generateInputDefinition( $prop, $isReq );
		}

		$out = [];
		$out[] = '|-';

		$labelLine = '! ' . $label;
		if ( $isReq ) {
			$labelLine .= '<span style="color:red;"> *</span>';
		}
		$labelLine .= ':';
		if ( $description !== '' ) {
			$labelLine .= ' <br><p class="pfFieldDescription" style="font-size:0.7em; color:gray;">'
				. htmlspecialchars( $description, ENT_QUOTES )
				. '</p>';
		}
		$out[] = $labelLine;

		$out[] = '| {{{field|' . $param . '|property=' . $this->s( $prop->getName() ) . '|' . $input . '}}}';

		return $out;
	}

	/**
	 * Generate input definition for "Has Type" property with SMW datatypes.
	 */
	private function generateHasTypeInput( bool $isRequired ): string {
		$datatypes = PropertyModel::getValidDatatypes();

		$params = [
			'input type=dropdown',
			'values=' . implode( ',', $datatypes )
		];

		if ( $isRequired ) {
			$params[] = 'mandatory=true';
		}

		return implode( '|', $params );
	}

	/**
	 * Subobject repeatable blocks.
	 */
	private function generateSubobjectSections( CategoryModel $category ): array {
		$required = $category->getRequiredSubobjects();
		$optional = $category->getOptionalSubobjects();

		$all = [];
		foreach ( $required as $n ) {
			$all[$n] = true;
		}
		foreach ( $optional as $n ) {
			if ( !isset( $all[$n] ) ) {
				$all[$n] = false;
			}
		}

		if ( empty( $all ) ) {
			return [];
		}

		$out = [];

		foreach ( $all as $subName => $isRequired ) {

			$model = $this->subobjectStore->readSubobject( $subName );
			if ( !$model instanceof SubobjectModel ) {
				wfLogWarning( "SemanticSchemas: Missing Subobject:$subName" );
				continue;
			}

			$label = $this->s( $model->getLabel() ?: $model->getName() );

			$out[] = '=== ' . $label . ' ===';
			$out[] = '';

			$templateName = 'Subobject/' . $this->s( $model->getName() );

			$for = [ $templateName, 'multiple' ];
			if ( $isRequired ) {
				$for[] = 'minimum instances=1';
			}

			$out[] = '{{{for template|' . implode( '|', $for ) . '}}}';
			$out[] = '';

			// Generate table for subobject properties
			$subProps = array_merge( $model->getRequiredProperties(), $model->getOptionalProperties() );
			if ( !empty( $subProps ) ) {
				$out[] = '{| class="formtable"';

				foreach ( $subProps as $p ) {
					$must = $model->isPropertyRequired( $p );
					$out = array_merge( $out, $this->generateTableField( $p, $category, $must ) );
				}

				$out[] = '|}';
				$out[] = '';
			}

			$out[] = '{{{end template}}}';
			$out[] = '';
		}

		return $out;
	}

	/* ----------------------------------------------------------
	 * Save + utilities
	 * -------------------------------------------------------- */

	public function updateForm( string $name, string $content ): bool {
		if ( trim( $name ) === '' ) {
			throw new \InvalidArgumentException( "Form name cannot be empty" );
		}

		$title = $this->pageCreator->makeTitle( $name, \PF_NS_FORM );
		if ( !$title ) {
			wfLogWarning( "SemanticSchemas: Unable to create form title for '$name'" );
			return false;
		}

		$result = $this->pageCreator->createOrUpdatePage(
			$title,
			$content,
			'SemanticSchemas: Auto-generated form'
		);

		// Purge the form page cache to ensure PageForms sees the updated content.
		// This is critical when form parameters like namespace targeting change,
		// as PageForms caches the parsed form definition.
		if ( $result ) {
			$this->pageCreator->purgePage( $title );
		}

		return $result;
	}

	public function generateAndSaveForm( CategoryModel $category ): bool {
		try {
			$txt = $this->generateForm( $category );
			return $this->updateForm( $category->getName(), $txt );
		} catch ( \Exception $e ) {
			wfLogWarning(
				"SemanticSchemas: Failed to gen/save form for {$category->getName()}: "
				. $e->getMessage()
			);
			return false;
		}
	}

	public function formExists( string $categoryName ): bool {
		$t = $this->pageCreator->makeTitle( $categoryName, \PF_NS_FORM );
		return $t && $this->pageCreator->pageExists( $t );
	}

	/**
	 * Find the parent category property in a category's schema.
	 */
	private function findParentCategoryProperty( CategoryModel $category ): ?string {
		$props = array_merge(
			$category->getRequiredProperties(),
			$category->getOptionalProperties()
		);

		foreach ( $props as $p ) {
			$lc = strtolower( $p );

			if (
				str_contains( $lc, 'parent' ) &&
				str_contains( $lc, 'category' )
			) {
				return $p;
			}
		}

		return null;
	}
}
