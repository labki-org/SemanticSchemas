<?php

namespace MediaWiki\Extension\SemanticSchemas\Generator;

use MediaWiki\Extension\SemanticSchemas\Schema\CategoryModel;
use MediaWiki\Extension\SemanticSchemas\Schema\ResolvedPropertySet;

/**
 * CompositeFormGenerator
 * ----------------------
 * Generates PageForms forms for multi-category page creation.
 *
 * Features:
 * - Multiple {{{for template}}} blocks (one per category)
 * - Shared properties appear once (in first template section)
 * - Category-specific properties in respective sections
 * - Alphabetical form naming (Category1+Category2)
 * - Standard PageForms structure with all inputs
 *
 * This enables creating wiki pages that belong to multiple categories
 * from a single form. Shared properties are shown once to avoid duplicate
 * form fields, while category-specific properties appear in their
 * respective template sections.
 */
class CompositeFormGenerator extends FormGenerator {

	/**
	 * Generate a composite form from a ResolvedPropertySet.
	 *
	 * @param ResolvedPropertySet $resolved Resolved properties from 2+ categories
	 * @return string PageForms wikitext
	 * @throws \InvalidArgumentException If less than 2 categories
	 */
	public function generateCompositeForm( ResolvedPropertySet $resolved ): string {
		$categories = $resolved->getCategoryNames();

		if ( count( $categories ) < 2 ) {
			throw new \InvalidArgumentException(
				'CompositeFormGenerator requires at least 2 categories, got ' . count( $categories )
			);
		}

		$lines = [];

		/* ----------------------------------------------------------
		 * <noinclude> Header
		 * -------------------------------------------------------- */
		$lines[] = '<noinclude>';
		$lines[] = '<!-- AUTO-GENERATED by SemanticSchemas - DO NOT EDIT MANUALLY -->';
		$lines[] = '<!-- This composite form is automatically regenerated -->';
		$lines[] = 'This is the form for creating pages belonging to multiple categories: '
			. implode( ', ', array_map( fn ( $c ) => '[[:Category:' . $this->s( $c ) . ']]', $categories ) ) . '.';
		$lines[] = '';

		$lines = array_merge( $lines, $this->generateFormInput( $categories ) );

		$lines[] = '</noinclude><includeonly>';
		$lines[] = '';

		/* ----------------------------------------------------------
		 * Page name info
		 * -------------------------------------------------------- */
		$lines[] = '{{{info|page name=<page name>}}}';
		$lines[] = '';

		/* ----------------------------------------------------------
		 * Template sections (one per category)
		 * -------------------------------------------------------- */
		$lines = array_merge( $lines, $this->generateTemplateSections( $resolved ) );

		/* ----------------------------------------------------------
		 * Category wikilinks
		 * -------------------------------------------------------- */
		foreach ( $categories as $cat ) {
			$lines[] = '[[Category:' . $this->s( $cat ) . ']]';
		}
		$lines[] = '';

		/* ----------------------------------------------------------
		 * Free text section
		 * -------------------------------------------------------- */
		$lines[] = "'''Free text:'''";
		$lines[] = '';
		$lines[] = '{{{standard input|free text|rows=10}}}';
		$lines[] = '';

		/* ----------------------------------------------------------
		 * Summary + Buttons
		 * -------------------------------------------------------- */
		$lines[] = '{{{standard input|summary}}}';
		$lines[] = '';
		$lines[] = '{{{standard input|save}}} '
			. '{{{standard input|preview}}} '
			. '{{{standard input|changes}}} '
			. '{{{standard input|cancel}}}';
		$lines[] = '</includeonly>';

		return implode( "\n", $lines );
	}

	/**
	 * Generate form input header with autocomplete.
	 *
	 * @param array $categories Category names
	 * @return array Lines of wikitext
	 */
	private function generateFormInput( array $categories ): array {
		$formName = $this->getCompositeFormName( $categories );

		$formInput = [
			'form=' . $formName,
		];

		return [
			'{{#forminput:' . implode( '|', $formInput ) . '}}',
			'',
		];
	}

	/**
	 * Generate template sections for all categories.
	 *
	 * First category gets ALL properties (including shared).
	 * Subsequent categories get only category-specific properties.
	 *
	 * @param ResolvedPropertySet $resolved
	 * @return array Lines of wikitext
	 */
	private function generateTemplateSections( ResolvedPropertySet $resolved ): array {
		$categories = $resolved->getCategoryNames();
		$lines = [];

		// Shared properties get their own box (mapped to first category's template)
		$sharedRequired = $this->getSharedProperties(
			$resolved->getRequiredProperties(), $resolved
		);
		$sharedOptional = $this->getSharedProperties(
			$resolved->getOptionalProperties(), $resolved
		);

		if ( !empty( $sharedRequired ) || !empty( $sharedOptional ) ) {
			$firstCategory = $categories[0];
			$lines[] = '{{{for template|' . $this->s( $firstCategory )
				. '|label=Shared Properties}}}';
			$lines[] = '';
			$lines = array_merge( $lines, $this->generatePropertySectionsForCategory(
				$sharedRequired, $sharedOptional, $firstCategory
			) );
			$lines[] = '{{{end template}}}';
			$lines[] = '';
		}

		// Per-category sections (category-specific properties only)
		foreach ( $categories as $categoryName ) {
			$lines = array_merge(
				$lines,
				$this->generateCategorySection( $categoryName, $resolved )
			);
		}

		return $lines;
	}

	/**
	 * Generate a single category's template section with category-specific properties.
	 *
	 * @param string $categoryName Category name
	 * @param ResolvedPropertySet $resolved Full resolved property set
	 * @return array Lines of wikitext
	 */
	private function generateCategorySection(
		string $categoryName,
		ResolvedPropertySet $resolved
	): array {
		$required = $this->getCategorySpecificProperties(
			$resolved->getRequiredProperties(), $categoryName, $resolved
		);
		$optional = $this->getCategorySpecificProperties(
			$resolved->getOptionalProperties(), $categoryName, $resolved
		);

		// Skip empty sections
		if ( empty( $required ) && empty( $optional ) ) {
			return [];
		}

		$lines = [];

		$lines[] = '{{{for template|' . $this->s( $categoryName ) . '|label='
			. $this->s( $categoryName ) . ' Properties}}}';
		$lines[] = '';

		$lines = array_merge( $lines, $this->generatePropertySectionsForCategory(
			$required, $optional, $categoryName
		) );

		$lines[] = '{{{end template}}}';
		$lines[] = '';

		return $lines;
	}

	/**
	 * Get shared properties (appear in 2+ categories).
	 *
	 * @param array $allProperties All properties to filter
	 * @param ResolvedPropertySet $resolved Resolved property set
	 * @return array Filtered property names
	 */
	private function getSharedProperties(
		array $allProperties,
		ResolvedPropertySet $resolved
	): array {
		$filtered = [];

		foreach ( $allProperties as $prop ) {
			if ( $resolved->isSharedProperty( $prop ) ) {
				$filtered[] = $prop;
			}
		}

		return $filtered;
	}

	/**
	 * Filter properties to only those specific to a category (not shared).
	 *
	 * @param array $allProperties All properties to filter
	 * @param string $categoryName Category to filter for
	 * @param ResolvedPropertySet $resolved Resolved property set
	 * @return array Filtered property names
	 */
	private function getCategorySpecificProperties(
		array $allProperties,
		string $categoryName,
		ResolvedPropertySet $resolved
	): array {
		$filtered = [];

		foreach ( $allProperties as $prop ) {
			$sources = $resolved->getPropertySources( $prop );

			// Include if this category is a source AND property is not shared
			if ( in_array( $categoryName, $sources, true ) && !$resolved->isSharedProperty( $prop ) ) {
				$filtered[] = $prop;
			}
		}

		return $filtered;
	}

	/**
	 * Generate property sections (required/optional) for a category.
	 *
	 * @param array $required Required properties
	 * @param array $optional Optional properties
	 * @param string $categoryName Category name (for mock CategoryModel)
	 * @return array Lines of wikitext
	 */
	private function generatePropertySectionsForCategory(
		array $required,
		array $optional,
		string $categoryName
	): array {
		// Create a mock CategoryModel for generatePropertySection compatibility
		// The CategoryModel is only used to check if properties are required,
		// which we already know from our parameters
		$mockCategory = new CategoryModel( $categoryName, [
			'properties' => [
				'required' => $required,
				'optional' => $optional,
			],
		] );

		$lines = [];

		// Required properties section
		if ( !empty( $required ) ) {
			$lines = array_merge(
				$lines,
				$this->generatePropertySection( $required, 'Required fields', $mockCategory, true )
			);
		}

		// Optional properties section
		if ( !empty( $optional ) ) {
			$lines = array_merge(
				$lines,
				$this->generatePropertySection( $optional, 'Optional fields', $mockCategory, false )
			);
		}

		return $lines;
	}

	/**
	 * Get composite form name from category names.
	 *
	 * Categories are sorted alphabetically and joined with '+'.
	 *
	 * @param array $categories Category names
	 * @return string Form name (e.g., "Employee+Person")
	 */
	public function getCompositeFormName( array $categories ): string {
		$sorted = $categories;
		sort( $sorted );
		return implode( '+', $sorted );
	}

	/**
	 * Generate and save a composite form.
	 *
	 * @param ResolvedPropertySet $resolved Resolved properties
	 * @return bool Success
	 */
	public function generateAndSaveCompositeForm( ResolvedPropertySet $resolved ): bool {
		try {
			$content = $this->generateCompositeForm( $resolved );
			$formName = $this->getCompositeFormName( $resolved->getCategoryNames() );

			$title = $this->pageCreator->makeTitle( $formName, \PF_NS_FORM );
			if ( !$title ) {
				wfLogWarning( "SemanticSchemas: Unable to create composite form title for '$formName'" );
				return false;
			}

			$result = $this->pageCreator->createOrUpdatePage(
				$title,
				$content,
				'SemanticSchemas: Auto-generated composite form'
			);

			// Purge cache
			if ( $result ) {
				$this->pageCreator->purgePage( $title );
			}

			return $result;

		} catch ( \Exception $e ) {
			wfLogWarning(
				"SemanticSchemas: Failed to generate/save composite form: " . $e->getMessage()
			);
			return false;
		}
	}
}
