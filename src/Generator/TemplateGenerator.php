<?php

namespace MediaWiki\Extension\StructureSync\Generator;

use MediaWiki\Extension\StructureSync\Schema\CategoryModel;
use MediaWiki\Extension\StructureSync\Store\PageCreator;
use MediaWiki\Extension\StructureSync\Schema\PropertyModel;
use MediaWiki\Extension\StructureSync\Util\NamingHelper;
use MediaWiki\Extension\StructureSync\Store\WikiSubobjectStore;
use MediaWiki\Extension\StructureSync\Schema\SubobjectModel;

/**
 * TemplateGenerator
 * -----------------
 * Generates two types of templates for each category:
 *   - Semantic templates   → Template:<Category>/semantic
 *   - Dispatcher templates → Template:<Category>
 *
 * Template Naming Conventions:
 * - Semantic: "Template:<CategoryName>/semantic"
 *   Stores SMW property values using {{#set:...}}
 * - Dispatcher: "Template:<CategoryName>"
 *   Coordinates semantic storage and display rendering
 *   Sets default form with {{#default_form:...}}
 * 
 * Architecture:
 * The three-template system (dispatcher, semantic, display) provides:
 * 1. Clean separation of concerns (data vs presentation)
 * 2. Allows display templates to be user-editable
 * 3. Enables automatic regeneration without breaking customizations
 * 
 * Template Flow:
 * Page → Dispatcher → Semantic (stores data) + Display (renders view)
 * 
 * Semantic templates store SMW data using #set.
 * Dispatcher templates wrap semantic + display templates.
 */
class TemplateGenerator
{

    /** @var PageCreator */
    private $pageCreator;

    /** @var WikiSubobjectStore */
    private $subobjectStore;

    /**
     * @param PageCreator|null $pageCreator
     * @param WikiSubobjectStore|null $subobjectStore
     */
    public function __construct(PageCreator $pageCreator = null, WikiSubobjectStore $subobjectStore = null)
    {
        $this->pageCreator = $pageCreator ?? new PageCreator();
        $this->subobjectStore = $subobjectStore ?? new WikiSubobjectStore();
    }

    /**
     * Sanitize a value to ensure MediaWiki never encounters null.
     *
     * @param string|null $value
     * @return string
     */
    private function sanitize(?string $value): string
    {
        return $value ?? '';
    }

    /* =====================================================================
     * SEMANTIC TEMPLATE
     * ===================================================================== */

    /**
     * Generate semantic template wikitext for a category.
     * 
     * Creates a template that stores all property values using SMW's {{#set:}}
     * parser function. Each property gets a parameter that maps to the SMW property.
     *
     * Output location:
     *   Template:<Category>/semantic
     * 
     * Generated structure:
     * - Noinclude header with metadata
     * - {{#set:...}} block with all properties
     * - Category annotation
     *
     * @param CategoryModel $category Effective (inherited) category
     * @return string Wikitext content for semantic template
     * @throws \InvalidArgumentException If category name is empty
     */
    public function generateSemanticTemplate(CategoryModel $category): string
    {
        if (trim($category->getName()) === '') {
            throw new \InvalidArgumentException('Category name cannot be empty');
        }

        $properties = $category->getAllProperties();
        
        // Note: Empty properties is valid - category might be purely organizational
        // or inherit all properties from parents
        
        sort($properties); // Deterministic output

        $lines = [];

        /* ------------------------------------------------------------------
         * NOINCLUDE HEADER
         * ------------------------------------------------------------------ */
        $lines[] = '<noinclude>';
        $lines[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
        $lines[] = '<!-- This semantic template stores SMW data for the category. -->';
        $lines[] = 'Semantic data template for [[:Category:' . $this->sanitize($category->getName()) . ']].';
        $lines[] = '</noinclude><includeonly>';

        /* ------------------------------------------------------------------
         * SMW DATA (#set)
         * ------------------------------------------------------------------ */
        $lines[] = '{{#set:';

        foreach ($properties as $property) {
            $param = $this->sanitize($this->propertyToParameter($property));
            $propertySafe = $this->sanitize($property);
            $lines[] = ' | ' . $propertySafe . ' = {{{' . $param . '|}}}';
        }

        $lines[] = '}}';
        
        /* ------------------------------------------------------------------
         * Category assignment (so pages using this template are categorized)
         * ------------------------------------------------------------------ */
        // Adding category membership for proper PageForms integration
        // With $smwgChangePropagationProtection = false, this no longer causes locks
        $lines[] = '';
        $lines[] = '[[Category:' . $this->sanitize($category->getName()) . ']]';

        $lines[] = '</includeonly>';

        return implode("\n", $lines);
    }

    /* =====================================================================
     * DISPATCHER TEMPLATE
     * ===================================================================== */

    /**
     * Generate dispatcher template wikitext for the category.
     * 
     * The dispatcher is the main template that users transclude on pages.
     * It coordinates the semantic and display templates, ensuring both
     * data storage and presentation happen correctly.
     *
     * Output location:
     *   Template:<Category>
     *
     * Dispatcher template ensures:
     *   - Default form is set (for "edit with form" link)
     *   - Semantic template applied (stores data)
     *   - Display template applied (renders view)
     * 
     * Template parameters are passed through to both sub-templates.
     *
     * @param CategoryModel $category Effective (inherited) category
     * @return string Wikitext content for dispatcher template
     * @throws \InvalidArgumentException If category name is empty
     */
    public function generateDispatcherTemplate(CategoryModel $category): string
    {
        if (trim($category->getName()) === '') {
            throw new \InvalidArgumentException('Category name cannot be empty');
        }

        $properties = $category->getAllProperties();
        
        // Note: Empty properties is valid - category might be purely organizational
        // or inherit all properties from parents
        
        sort($properties);

        $name = $this->sanitize($category->getName());

        $lines = [];

        /* ------------------------------------------------------------------
         * NOINCLUDE
         * ------------------------------------------------------------------ */
        $lines[] = '<noinclude>';
        $lines[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
        $lines[] = '<!-- This dispatcher template loads semantic + display templates. -->';
        $lines[] = 'Dispatcher for [[:Category:' . $name . ']].';
        $lines[] = '* Semantic: [[Template:' . $name . '/semantic]]';
        $lines[] = '* Display:  [[Template:' . $name . '/display]]';
        $lines[] = '</noinclude><includeonly>';

        /* ------------------------------------------------------------------
         * DEFAULT FORM (for "edit with form" button)
         * ------------------------------------------------------------------ */
        $lines[] = '{{#default_form:' . $name . '}}';
        $lines[] = '';

        /* ------------------------------------------------------------------
         * SEMANTIC TEMPLATE INCLUDE
         * ------------------------------------------------------------------ */
        $lines[] = '{{' . $name . '/semantic';
        foreach ($properties as $property) {
            $param = $this->sanitize($this->propertyToParameter($property));
            $lines[] = ' | ' . $param . ' = {{{' . $param . '|}}}';
        }
        $lines[] = '}}';
        $lines[] = '';

        /* ------------------------------------------------------------------
         * DISPLAY TEMPLATE INCLUDE
         * ------------------------------------------------------------------ */

        $lines[] = '{{' . $name . '/display';
        foreach ($properties as $property) {
            $param = $this->sanitize($this->propertyToParameter($property));
            $lines[] = ' | ' . $param . ' = {{{' . $param . '|}}}';
        }
        $lines[] = '}}';
        $lines[] = '';

        /* ------------------------------------------------------------------
         * SUBOBJECT DISPLAY SECTIONS
         * ------------------------------------------------------------------ */
        $subgroupLines = $this->generateSubobjectDisplaySections( $category );
        if ( !empty( $subgroupLines ) ) {
            $lines = array_merge( $lines, $subgroupLines );
        }

        $lines[] = '</includeonly>';

        return implode("\n", $lines);
    }


    /* =====================================================================
     * TEMPLATE CREATION / UPDATING
     * ===================================================================== */

    /**
     * Create or update a template page.
     * 
     * Handles the actual page creation/update operation with error handling.
     *
     * @param string $templateName  Name without namespace prefix
     * @param string $content Wikitext content
     * @return bool True on success, false on failure
     * @throws \InvalidArgumentException If template name is empty
     */
    public function updateTemplate(string $templateName, string $content): bool
    {
        if (trim($templateName) === '') {
            throw new \InvalidArgumentException('Template name cannot be empty');
        }

        $title = $this->pageCreator->makeTitle($templateName, NS_TEMPLATE);
        if (!$title) {
            wfLogWarning("StructureSync: Failed to create Title for template '$templateName'");
            return false;
        }

        $summary = 'StructureSync: Auto-generated template';
        $result = $this->pageCreator->createOrUpdatePage($title, $content, $summary);
        
        if (!$result) {
            wfLogWarning("StructureSync: Failed to save template '$templateName'");
        }
        
        return $result;
    }

    /**
     * Create per-subgroup templates for a category.
     *
     * @param CategoryModel $category
     * @return string[] Errors encountered (if any)
     */
    private function generateSubgroupTemplates( CategoryModel $category ): array {
        $errors = [];
        $subgroups = array_unique(
            array_merge(
                $category->getRequiredSubgroups(),
                $category->getOptionalSubgroups()
            )
        );

        if ( empty( $subgroups ) ) {
            return $errors;
        }

        foreach ( $subgroups as $subgroupName ) {
            try {
                $subobject = $this->subobjectStore->readSubobject( $subgroupName );
                if ( !$subobject instanceof SubobjectModel ) {
                    $errors[] = "Missing subobject definition for '$subgroupName'";
                    continue;
                }

                $content = $this->generateSubgroupTemplate( $category, $subobject );
                $templateName = NamingHelper::subgroupTemplateName( $category->getName(), $subgroupName );
                if ( !$this->updateTemplate( $templateName, $content ) ) {
                    $errors[] = "Failed to create subgroup template '$templateName'";
                }
            } catch ( \Exception $e ) {
                $errors[] = "Error generating subgroup template for '$subgroupName': " . $e->getMessage();
            }
        }
        
        // Generate helper templates for displaying subobjects in tables
        try {
            $this->generateSubobjectDisplayHelpers( $category );
        } catch ( \Exception $e ) {
            $errors[] = "Error generating subobject display helpers: " . $e->getMessage();
        }

        return $errors;
    }

    /**
     * Build wikitext for a subgroup template.
     *
     * @param CategoryModel $category
     * @param SubobjectModel $subobject
     * @return string
     */
    private function generateSubgroupTemplate( CategoryModel $category, SubobjectModel $subobject ): string {
        $categoryName = $this->sanitize( $category->getName() );
        $subobjectName = $this->sanitize( $subobject->getName() );

        $lines = [];
        $lines[] = '<noinclude>';
        $lines[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
        $lines[] = 'Subobject template for [[:Category:' . $categoryName . ']] using [[Subobject:' . $subobjectName . ']].';
        $lines[] = '</noinclude><includeonly>';
        $lines[] = '{{#subobject:';
        $lines[] = ' | Has subgroup type = Subobject:' . $subobjectName;

        $properties = array_merge(
            $subobject->getRequiredProperties(),
            $subobject->getOptionalProperties()
        );

        foreach ( $properties as $propertyName ) {
            $param = $this->sanitize( $this->propertyToParameter( $propertyName ) );
            $lines[] = ' | ' . $this->sanitize( $propertyName ) . ' = {{{' . $param . '|}}}';
        }

        $lines[] = '}}';
        $lines[] = '</includeonly>';

        return implode( "\n", $lines );
    }

    /**
     * Generate helper templates for displaying subobjects in tables.
     * 
     * Creates:
     * - {Category}/subobject-intro: Empty (table header is in main template)
     * - {Category}/subobject-outro: Empty
     * - {Category}/subobject-row-{SubobjectName}: Formats one row for a specific subgroup
     *
     * @param CategoryModel $category
     */
    private function generateSubobjectDisplayHelpers( CategoryModel $category ): void {
        $categoryName = $this->sanitize( $category->getName() );
        
        $allSubgroups = array_unique(
            array_merge(
                $category->getRequiredSubgroups(),
                $category->getOptionalSubgroups()
            )
        );
        
        if ( empty( $allSubgroups ) ) {
            return;
        }
        
        // Intro template (empty - table header is in dispatcher)
        $introContent = '<noinclude>Helper template for subobject display intro.</noinclude>';
        $this->updateTemplate( $categoryName . '/subobject-intro', $introContent );
        
        // Outro template (empty)
        $outroContent = '<noinclude>Helper template for subobject display outro.</noinclude>';
        $this->updateTemplate( $categoryName . '/subobject-outro', $outroContent );
        
        // Generate specific row templates for each subgroup
        foreach ( $allSubgroups as $subgroupName ) {
            $subobject = $this->subobjectStore->readSubobject( $subgroupName );
            if ( !$subobject instanceof SubobjectModel ) {
                continue;
            }
            
            $properties = $subobject->getAllProperties();
            
            $rowLines = [];
            $rowLines[] = '<noinclude>Helper template for subobject display row.</noinclude><includeonly>';
            $rowLines[] = '|-';
            
            // SMW format=template passes the result subject as {{{1}}}.
            // Printout properties start at {{{2}}}.
            $paramNum = 2;
            foreach ( $properties as $propertyName ) {
                $rowLines[] = '| {{{' . $paramNum . '|}}}';
                $paramNum++;
            }
            
            $rowLines[] = '</includeonly>';
            
            // Template name: {Category}/subobject-row-{SubobjectName}
            // We sanitize the subobject name to be safe for filenames
            $safeSubName = str_replace( ' ', '_', $subobject->getName() );
            $this->updateTemplate( $categoryName . '/subobject-row-' . $safeSubName, implode( "\n", $rowLines ) );
        }
    }

    /**
     * Generate subobject display sections for the dispatcher template.
     * 
     * Creates wikitext that queries and displays subobjects in tables.
     * Uses SMW #ask queries to fetch subobjects by type.
     *
     * @param CategoryModel $category
     * @return array Lines of wikitext
     */
    private function generateSubobjectDisplaySections( CategoryModel $category ): array {
        $lines = [];
        
        $allSubgroups = array_unique(
            array_merge(
                $category->getRequiredSubgroups(),
                $category->getOptionalSubgroups()
            )
        );
        
        if ( empty( $allSubgroups ) ) {
            return $lines;
        }
        
        foreach ( $allSubgroups as $subgroupName ) {
            $subobject = $this->subobjectStore->readSubobject( $subgroupName );
            if ( !$subobject instanceof SubobjectModel ) {
                continue;
            }
            
            $label = $this->sanitize( $subobject->getLabel() ?: $subobject->getName() );
            $properties = $subobject->getAllProperties();
            
            if ( empty( $properties ) ) {
                continue;
            }
            
            $lines[] = '=== ' . $label . ' ===';
            $lines[] = '';
            
            // Build wikitext table
            $lines[] = '{| class="wikitable ss-subgroup-table"';
            $lines[] = '|-';
            
            // Header row
            foreach ( $properties as $propertyName ) {
                $propertyLabel = $this->getPropertyLabel( $propertyName );
                $lines[] = '! ' . $this->sanitize( $propertyLabel );
            }
            
            // Query for subobjects of this type
            // Use inverse property of "Has subobject" to find subobjects belonging to this page
            $lines[] = '{{#ask: [[-Has subobject::{{FULLPAGENAME}}]] [[Has subgroup type::Subobject:' . $this->sanitize( $subgroupName ) . ']]';
            
            // Build printout statements for each property
            foreach ( $properties as $propertyName ) {
                $lines[] = ' |?' . $this->sanitize( $propertyName );
            }
            
            // Format as table rows
            $lines[] = ' |format=template';
            $safeSubName = str_replace( ' ', '_', $subobject->getName() );
            $lines[] = ' |template=' . $this->sanitize( $category->getName() ) . '/subobject-row-' . $safeSubName;
            $lines[] = ' |introtemplate=' . $this->sanitize( $category->getName() ) . '/subobject-intro';
            $lines[] = ' |outrotemplate=' . $this->sanitize( $category->getName() ) . '/subobject-outro';
            $lines[] = ' |default=<tr><td colspan="' . count( $properties ) . '">No entries yet.</td></tr>';
            $lines[] = '}}';
            
            $lines[] = '|}';
            $lines[] = '';
        }
        
        return $lines;
    }

    /**
     * Generate semantic + dispatcher templates for a category.
     * 
     * This is the main entry point for template generation. It creates both
     * templates in the correct order and reports any failures.
     * 
     * The operation continues even if one template fails, but reports all errors.
     *
     * @param CategoryModel $category Category to generate templates for
     * @return array{success:bool,errors:string[]} Result with overall success and error list
     */
    public function generateAllTemplates(CategoryModel $category): array
    {

        $result = ['success' => true, 'errors' => []];
        $name = $category->getName();

        try {
            /* --------------------------------------------------------------
             * SEMANTIC TEMPLATE
             * -------------------------------------------------------------- */
            $semantic = $this->generateSemanticTemplate($category);
            if (!$this->updateTemplate($name . '/semantic', $semantic)) {
                $result['success'] = false;
                $result['errors'][] = "Failed to create semantic template for $name";
            }
        } catch (\Exception $e) {
            $result['success'] = false;
            $result['errors'][] = "Error generating semantic template for $name: " . $e->getMessage();
        }

        try {
            /* --------------------------------------------------------------
             * DISPATCHER TEMPLATE
             * -------------------------------------------------------------- */
            $dispatcher = $this->generateDispatcherTemplate($category);
            if (!$this->updateTemplate($name, $dispatcher)) {
                $result['success'] = false;
                $result['errors'][] = "Failed to create dispatcher template for $name";
            }
        } catch (\Exception $e) {
            $result['success'] = false;
            $result['errors'][] = "Error generating dispatcher template for $name: " . $e->getMessage();
        }

        try {
            $subErrors = $this->generateSubgroupTemplates( $category );
            if ( !empty( $subErrors ) ) {
                $result['success'] = false;
                $result['errors'] = array_merge( $result['errors'], $subErrors );
            }
        } catch ( \Exception $e ) {
            $result['success'] = false;
            $result['errors'][] = "Error generating subgroup templates for $name: " . $e->getMessage();
        }

        return $result;
    }

    /* =====================================================================
     * UTILITIES
     * ===================================================================== */

    /**
     * Convert SMW property names → PageForms parameter names.
     * 
     * Delegates to NamingHelper for consistent transformation across all generators.
     *
     * @param string $propertyName SMW property name
     * @return string Normalized parameter name
     */
    private function propertyToParameter(string $propertyName): string
    {
        return NamingHelper::propertyToParameter($propertyName);
    }

    /**
     * Get property label for display.
     *
     * @param string $propertyName
     * @return string
     */
    private function getPropertyLabel( string $propertyName ): string {
        return NamingHelper::generatePropertyLabel( $propertyName );
    }

    /**
     * Check if semantic template exists.
     *
     * @param string $categoryName
     * @return bool
     */
    public function semanticTemplateExists(string $categoryName): bool
    {
        $title = $this->pageCreator->makeTitle($categoryName . '/semantic', NS_TEMPLATE);
        return $title && $this->pageCreator->pageExists($title);
    }

    /**
     * Check if dispatcher template exists.
     *
     * @param string $categoryName
     * @return bool
     */
    public function dispatcherTemplateExists(string $categoryName): bool
    {
        $title = $this->pageCreator->makeTitle($categoryName, NS_TEMPLATE);
        return $title && $this->pageCreator->pageExists($title);
    }
}
