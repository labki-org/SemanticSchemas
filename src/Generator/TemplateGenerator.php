<?php

namespace MediaWiki\Extension\SemanticSchemas\Generator;

use InvalidArgumentException;
use MediaWiki\Extension\SemanticSchemas\Schema\CategoryModel;
use MediaWiki\Extension\SemanticSchemas\Schema\PropertyModel;
use MediaWiki\Extension\SemanticSchemas\Schema\SubobjectModel;
use MediaWiki\Extension\SemanticSchemas\Store\PageCreator;
use MediaWiki\Extension\SemanticSchemas\Store\WikiPropertyStore;
use MediaWiki\Extension\SemanticSchemas\Store\WikiSubobjectStore;
use MediaWiki\Extension\SemanticSchemas\Util\NamingHelper;

/**
 * Generates core templates for proper Semantic MediaWiki functioning.
 *
 * Responsibilities:
 *   - Semantic template: Template:<Category>/semantic (stores data via #set)
 *   - Dispatcher template: Template:<Category> (coordinates form, storage, and display)
 *   - Subobject templates: Template:Subobject/<Name> (for nested data)
 */
class TemplateGenerator
{

    private PageCreator $pageCreator;
    private WikiSubobjectStore $subobjectStore;
    private WikiPropertyStore $propertyStore;

    public function __construct(
        ?PageCreator $pageCreator = null,
        ?WikiSubobjectStore $subobjectStore = null,
        ?WikiPropertyStore $propertyStore = null
    ) {
        $this->pageCreator = $pageCreator ?? new PageCreator();
        $this->subobjectStore = $subobjectStore ?? new WikiSubobjectStore();
        $this->propertyStore = $propertyStore ?? new WikiPropertyStore();
    }

    /* =====================================================================
     * SEMANTIC TEMPLATE  (Template:<Category>/semantic)
     * ===================================================================== */

    /**
     * Generate content for the semantic template.
     *
     * For Page-type properties with allowedNamespace (e.g., Property, Category),
     * this method generates template logic to prepend the namespace prefix to values.
     * This ensures SMW correctly interprets them as page references rather than
     * plain text, which is required for proper semantic querying.
     *
     * @param CategoryModel $category
     * @return string
     */
    public function generateSemanticTemplate(CategoryModel $category): string
    {
        $name = trim($category->getName());
        if ($name === '') {
            throw new InvalidArgumentException("Category name cannot be empty");
        }

        $props = $category->getAllProperties();
        sort($props);

        $out = [];
        $out[] = '<noinclude>';
        $out[] = '<!-- AUTO-GENERATED by SemanticSchemas - DO NOT EDIT MANUALLY -->';
        $out[] = 'Semantic template for Category:' . ($name ?? '');
        $out[] = '</noinclude><includeonly>';
        $out[] = '{{#set:';

        foreach ($props as $p) {
            $param = NamingHelper::propertyToParameter($p);
            $valueExpr = $this->generatePropertyValueExpression($p, $param);
            $out[] = ' | ' . ($p ?? '') . ' = ' . $valueExpr;
        }

        $out[] = '}}';
        $out[] = '';
        $out[] = '[[Category:' . ($name ?? '') . ']]';
        $out[] = '</includeonly>';

        return implode("\n", $out);
    }

    /**
     * Generate the value expression for a property in a semantic template.
     *
     * For Page-type properties with allowedNamespace, this adds the namespace
     * prefix to ensure SMW correctly interprets values as page references.
     * For multi-value properties, uses #arraymap to prefix each value.
     *
     * @param string $propertyName The SMW property name
     * @param string $param The template parameter name
     * @return string The wikitext expression for the value
     */
    private function generatePropertyValueExpression(string $propertyName, string $param): string
    {
        // Try to look up the property definition
        $propModel = $this->propertyStore->readProperty($propertyName);

        // If no property definition or not a Page type with namespace, use simple passthrough
        if (!$propModel instanceof PropertyModel) {
            return '{{{' . $param . '|}}}';
        }

        $allowedNamespace = $propModel->getAllowedNamespace();

        // Not a Page type with namespace restriction - simple passthrough
        if (!$propModel->isPageType() || $allowedNamespace === null || $allowedNamespace === '') {
            return '{{{' . $param . '|}}}';
        }

        // Page-type property with allowedNamespace - need to prefix values
        if ($propModel->allowsMultipleValues()) {
            // Multi-value: use #arraymap to prefix each comma-separated value
            // The inner #if prevents prefixing empty items after trimming
            // Format: {{#arraymap:{{{param|}}}|,|@@item@@|{{#if:@@item@@|Namespace:@@item@@}}|,}}
            return '{{#arraymap:{{{' . $param . '|}}}|,|@@item@@|{{#if:@@item@@|' . $allowedNamespace . ':@@item@@}}|,}}';
        }

        // Single value: use #if to conditionally prefix (avoids "Namespace:" for empty values)
        // Format: {{#if:{{{param|}}}|Namespace:{{{param|}}}|}}
        return '{{#if:{{{' . $param . '|}}}|' . $allowedNamespace . ':{{{' . $param . '|}}}|}}';
    }

    /* =====================================================================
     * DISPATCHER TEMPLATE (Template:<Category>)
     * ===================================================================== */

    /**
     * Generate content for the dispatcher template.
     *
     * @param CategoryModel $category
     * @return string
     */
    public function generateDispatcherTemplate(CategoryModel $category): string
    {
        $name = trim($category->getName());
        if ($name === '') {
            throw new InvalidArgumentException("Category name cannot be empty");
        }

        $props = $category->getAllProperties();
        sort($props);

        $cat = $name;

        $out = [];
        $out[] = '<noinclude>';
        $out[] = '<!-- AUTO-GENERATED by SemanticSchemas - DO NOT EDIT MANUALLY -->';
        $out[] = 'Dispatcher template for Category:' . $cat;
        $out[] = '</noinclude><includeonly>';
        $out[] = '{{#default_form:' . $cat . '}}';
        $out[] = '';

        /* Semantic storage */
        $out[] = '{{' . $cat . '/semantic';
        foreach ($props as $p) {
            $param = NamingHelper::propertyToParameter($p);
            $out[] = ' | ' . $param . ' = {{{' . $param . '|}}}';
        }
        $out[] = '}}';
        $out[] = '';

        /* Display template (delegated to static display template) */
        $out[] = '{{' . $cat . '/display';
        foreach ($props as $p) {
            $param = NamingHelper::propertyToParameter($p);
            $out[] = ' | ' . $param . ' = {{{' . $param . '|}}}';
        }
        $out[] = '}}';
        $out[] = '';

        /* Subobject Sections */
        $out = array_merge(
            $out,
            $this->generateSubobjectDisplaySections($category)
        );

        /* Hierarchy Widget (Bottom of page) */
        $out[] = '';
        $out[] = '{{#semanticschemas_hierarchy:' . $cat . '}}';

        $out[] = '</includeonly>';

        return implode("\n", $out);
    }

    /* =====================================================================
     * SUBOBJECT TEMPLATES  (Template:Subobject/<Name>)
     * ===================================================================== */

    private function generateSubobjectTemplate(SubobjectModel $sub): string
    {
        $name = $sub->getName() ?? '';

        $out = [];
        $out[] = '<noinclude>';
        $out[] = '<!-- AUTO-GENERATED by SemanticSchemas - DO NOT EDIT MANUALLY -->';
        $out[] = 'Subobject semantic template for Subobject:' . $name;
        $out[] = '</noinclude><includeonly>';

        $out[] = '{{#subobject:';
        $out[] = ' | Has subobject type = Subobject:' . $name;

        $props = array_merge(
            $sub->getRequiredProperties(),
            $sub->getOptionalProperties()
        );

        foreach ($props as $p) {
            $param = NamingHelper::propertyToParameter($p);
            $valueExpr = $this->generatePropertyValueExpression($p, $param);
            $out[] = ' | ' . ($p ?? '') . ' = ' . $valueExpr;
        }

        $out[] = '}}';
        $out[] = '</includeonly>';

        return implode("\n", $out);
    }

    private function generateSubobjectRowTemplate(SubobjectModel $sub): string
    {
        $name = $sub->getName() ?? '';
        $props = $sub->getAllProperties();

        $out = [];
        $out[] = '<noinclude>Auto-generated row template for subobject ' . $name . '</noinclude>';
        $out[] = '<includeonly>';
        $out[] = '|-';

        $i = 2;
        foreach ($props as $p) {
            $out[] = '| {{{' . $i . '|}}}';
            $i++;
        }

        $out[] = '</includeonly>';

        return implode("\n", $out);
    }

    /* =====================================================================
     * SUBOBJECT DISPLAY
     * ===================================================================== */

    private function generateSubobjectDisplaySections(CategoryModel $category): array
    {
        $required = $category->getRequiredSubobjects();
        $optional = $category->getOptionalSubobjects();

        $all = array_unique(array_merge($required, $optional));
        if (empty($all)) {
            return [];
        }

        $out = [];

        foreach ($all as $subName) {
            $sub = $this->subobjectStore->readSubobject($subName);
            if (!$sub instanceof SubobjectModel) {
                wfLogWarning("SemanticSchemas: Missing subobject definition '$subName'");
                continue;
            }

            $label = $sub->getLabel() ?: $sub->getName();
            $props = $sub->getAllProperties();
            if (empty($props)) {
                continue;
            }

            $out[] = '=== ' . ($label ?? '') . ' ===';
            $out[] = '';
            $out[] = '{| class="wikitable ss-subobject-table"';
            $out[] = '|-';

            /* header row */
            foreach ($props as $p) {
                $lab = NamingHelper::generatePropertyLabel($p);
                $out[] = '! ' . ($lab ?? '');
            }

            /* SMW #ask invocation */
            $out[] = '{{#ask: [[-Has subobject::{{FULLPAGENAME}}]] [[Has subobject type::Subobject:' . ($subName ?? '') . ']]';

            foreach ($props as $p) {
                $out[] = ' | ?' . ($p ?? '');
            }

            $rowTemplate = 'Subobject/' . ($subName ?? '') . '/row';

            $out[] = ' | format=template';
            $out[] = ' | template=' . $rowTemplate;
            $out[] = ' | default=<tr><td colspan="' . count($props) . '">No entries yet.</td></tr>';
            $out[] = '}}';
            $out[] = '|}';
            $out[] = '';
        }

        return $out;
    }

    /* =====================================================================
     * PUBLIC: FULL TEMPLATE GENERATION ENTRYPOINT
     * ===================================================================== */

    /**
     * Generate all artifacts for a category (semantic, dispatcher, subobjects).
     *
     * @param CategoryModel $category
     * @return array{success: bool, errors: string[]}
     */
    public function generateAllTemplates(CategoryModel $category): array
    {
        $errors = [];
        $name = $category->getName();

        /* Category semantic template */
        try {
            $content = $this->generateSemanticTemplate($category);
            $this->updateTemplate($name . '/semantic', $content);
        } catch (\Exception $e) {
            $errors[] = "Error generating semantic template for $name: " . $e->getMessage();
        }

        /* Dispatcher template */
        try {
            $content = $this->generateDispatcherTemplate($category);
            $this->updateTemplate($name, $content);
        } catch (\Exception $e) {
            $errors[] = "Error generating dispatcher template for $name: " . $e->getMessage();
        }

        /* Subobject templates */
        $subs = array_unique(array_merge(
            $category->getRequiredSubobjects(),
            $category->getOptionalSubobjects()
        ));

        foreach ($subs as $subName) {
            try {
                $sub = $this->subobjectStore->readSubobject($subName);
                if (!$sub instanceof SubobjectModel) {
                    $errors[] = "Missing subobject '$subName'";
                    continue;
                }

                /* semantic template */
                $content = $this->generateSubobjectTemplate($sub);
                $this->updateTemplate('Subobject/' . $sub->getName(), $content);

                /* row template */
                $rowContent = $this->generateSubobjectRowTemplate($sub);
                $this->updateTemplate('Subobject/' . $sub->getName() . '/row', $rowContent);

            } catch (\Exception $e) {
                $errors[] = "Error generating templates for subobject '$subName': " . $e->getMessage();
            }
        }

        return [
            'success' => empty($errors),
            'errors' => $errors
        ];
    }

    /* =====================================================================
     * BASIC UPDATE WRAPPER
     * ===================================================================== */

    private function updateTemplate(string $name, string $content): bool
    {
        if (trim($name) === '') {
            throw new InvalidArgumentException("Template name cannot be empty");
        }

        $title = $this->pageCreator->makeTitle($name, NS_TEMPLATE);
        if (!$title) {
            wfLogWarning("SemanticSchemas: Failed to create Title for template '$name'");
            return false;
        }

        return $this->pageCreator->createOrUpdatePage(
            $title,
            $content,
            'SemanticSchemas: Auto-generated template'
        );
    }

    /**
     * Check if the semantic template exists for a category.
     *
     * @param string $categoryName
     * @return bool
     */
    public function semanticTemplateExists(string $categoryName): bool
    {
        $templateName = trim($categoryName) . '/semantic';
        $title = $this->pageCreator->makeTitle($templateName, NS_TEMPLATE);
        return $title && $this->pageCreator->pageExists($title);
    }
}
