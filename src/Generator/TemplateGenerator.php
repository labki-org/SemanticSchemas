<?php

namespace MediaWiki\Extension\StructureSync\Generator;

use MediaWiki\Extension\StructureSync\Schema\CategoryModel;
use MediaWiki\Extension\StructureSync\Schema\PropertyModel;
use MediaWiki\Extension\StructureSync\Schema\SubobjectModel;
use MediaWiki\Extension\StructureSync\Store\PageCreator;
use MediaWiki\Extension\StructureSync\Store\WikiSubobjectStore;
use MediaWiki\Extension\StructureSync\Util\NamingHelper;

/**
 * TemplateGenerator (Rewritten 2025)
 * ----------------------------------
 *
 * Generates:
 *   - Semantic template: Template:<Category>/semantic
 *   - Dispatcher template: Template:<Category>
 *   - Subobject semantic templates: Template:Subobject/<Name>
 *   - Subobject row templates:      Template:Subobject/<Name>/row
 *
 * The rewritten architecture fully matches the rewritten FormGenerator and new
 * StructureSync Subobject model:
 *
 *   - Subobject templates are global: Template:Subobject/<Name>
 *   - Category templates are not polluted with subobject helpers
 *   - Display template Template:<Category>/display is user-editable and untouched
 *   - Dispatcher coordinates three actions:
 *       * #default_form
 *       * semantic storage
 *       * display rendering
 *       * subobject table sections
 */
class TemplateGenerator {

    private PageCreator $pageCreator;
    private WikiSubobjectStore $subobjectStore;

    public function __construct(
        PageCreator $pageCreator = null,
        WikiSubobjectStore $subobjectStore = null
    ) {
        $this->pageCreator     = $pageCreator     ?? new PageCreator();
        $this->subobjectStore  = $subobjectStore  ?? new WikiSubobjectStore();
    }

    private function s(?string $v): string {
        return $v ?? '';
    }

    /* =====================================================================
     * SEMANTIC TEMPLATE  (Template:<Category>/semantic)
     * ===================================================================== */

    public function generateSemanticTemplate( CategoryModel $category ): string {

        $name = trim( $category->getName() );
        if ($name === '') {
            throw new \InvalidArgumentException("Category name cannot be empty");
        }

        $props = $category->getAllProperties();
        sort($props);

        $out = [];
        $out[] = '<noinclude>';
        $out[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
        $out[] = 'Semantic template for Category:' . $this->s($name);
        $out[] = '</noinclude><includeonly>';
        $out[] = '{{#set:';

        foreach ($props as $p) {
            $param = NamingHelper::propertyToParameter($p);
            $out[] = ' | ' . $this->s($p) . ' = {{{' . $this->s($param) . '|}}}';
        }

        $out[] = '}}';
        $out[] = '';
        $out[] = '[[Category:' . $this->s($name) . ']]';
        $out[] = '</includeonly>';

        return implode("\n", $out);
    }

    /* =====================================================================
     * DISPATCHER TEMPLATE (Template:<Category>)
     * ===================================================================== */

    public function generateDispatcherTemplate( CategoryModel $category ): string {

        $name = trim( $category->getName() );
        if ($name === '') {
            throw new \InvalidArgumentException("Category name cannot be empty");
        }

        $props = $category->getAllProperties();
        sort($props);

        $cat = $this->s($name);

        $out = [];
        $out[] = '<noinclude>';
        $out[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
        $out[] = 'Dispatcher template for Category:' . $cat;
        $out[] = '</noinclude><includeonly>';
        $out[] = '{{#default_form:' . $cat . '}}';
        $out[] = '';

        /* Semantic storage */
        $out[] = '{{' . $cat . '/semantic';
        foreach ($props as $p) {
            $param = NamingHelper::propertyToParameter($p);
            $out[] = ' | ' . $param . ' = {{{' . $param . '|}}}';
        }
        $out[] = '}}';
        $out[] = '';

        /* Display template */
        $out[] = '{{' . $cat . '/display';
        foreach ($props as $p) {
            $param = NamingHelper::propertyToParameter($p);
            $out[] = ' | ' . $param . ' = {{{' . $param . '|}}}';
        }
        $out[] = '}}';
        $out[] = '';

        /* Subobject Sections */
        $out = array_merge(
            $out,
            $this->generateSubobjectDisplaySections( $category )
        );

        $out[] = '</includeonly>';

        return implode("\n", $out);
    }

    /* =====================================================================
     * SUBOBJECT TEMPLATES  (Template:Subobject/<Name>)
     * ===================================================================== */

    /**
     * Build semantic template for a subobject:
     *
     *     Template:Subobject/<Name>
     *
     * Format:
     *   {{#subobject:
     *      | Has subgroup type = Subobject:<Name>
     *      | Property = {{{param}}}
     *   }}
     */
    private function generateSubobjectTemplate( SubobjectModel $sub ): string {

        $name = $this->s( $sub->getName() );

        $out = [];
        $out[] = '<noinclude>';
        $out[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
        $out[] = 'Subobject semantic template for Subobject:' . $name;
        $out[] = '</noinclude><includeonly>';

        $out[] = '{{#subobject:';
        $out[] = ' | Has subgroup type = Subobject:' . $name;

        $props = array_merge(
            $sub->getRequiredProperties(),
            $sub->getOptionalProperties()
        );

        foreach ($props as $p) {
            $param = NamingHelper::propertyToParameter($p);
            $out[] = ' | ' . $this->s($p) . ' = {{{' . $this->s($param) . '|}}}';
        }

        $out[] = '}}';
        $out[] = '</includeonly>';

        return implode("\n", $out);
    }

    /**
     * Row template for displaying subobject instances in #ask:
     *
     * Template:Subobject/<Name>/row
     *
     * Parameters:
     *   {{{2}}}, {{{3}}}, ... mapped to printouts.
     */
    private function generateSubobjectRowTemplate( SubobjectModel $sub ): string {

        $name = $this->s( $sub->getName() );
        $props = $sub->getAllProperties();

        $out = [];
        $out[] = '<noinclude>Auto-generated row template for subobject ' . $name . '</noinclude>';
        $out[] = '<includeonly>';
        $out[] = '|-';

        $i = 2;
        foreach ($props as $p) {
            $out[] = '| {{{' . $i . '|}}}';
            $i++;
        }

        $out[] = '</includeonly>';

        return implode("\n", $out);
    }

    /* =====================================================================
     * SUBOBJECT DISPLAY
     * ===================================================================== */

    /**
     * Build per-subgroup display tables inside the dispatcher template.
     */
    private function generateSubobjectDisplaySections( CategoryModel $category ): array {

        $required = $category->getRequiredSubgroups();
        $optional = $category->getOptionalSubgroups();

        $all = array_unique( array_merge( $required, $optional ) );
        if (empty($all)) {
            return [];
        }

        $out = [];

        foreach ($all as $subName) {

            $sub = $this->subobjectStore->readSubobject( $subName );
            if (!$sub instanceof SubobjectModel) {
                wfLogWarning("StructureSync: Missing subobject definition '$subName'");
                continue;
            }

            $label = $this->s( $sub->getLabel() ?: $sub->getName() );
            $props = $sub->getAllProperties();
            if (empty($props)) {
                continue;
            }

            $out[] = '=== ' . $label . ' ===';
            $out[] = '';
            $out[] = '{| class="wikitable ss-subobject-table"';
            $out[] = '|-';

            /* header row */
            foreach ($props as $p) {
                $lab = NamingHelper::generatePropertyLabel( $p );
                $out[] = '! ' . $this->s($lab);
            }

            /* SMW #ask invocation */
            $out[] = '{{#ask: [[-Has subobject::{{FULLPAGENAME}}]] [[Has subgroup type::Subobject:' . $this->s($subName) . ']]';

            foreach ($props as $p) {
                $out[] = ' | ?' . $this->s($p);
            }

            $rowTemplate = 'Subobject/' . $this->s($subName) . '/row';

            $out[] = ' | format=template';
            $out[] = ' | template=' . $rowTemplate;
            $out[] = ' | default=<tr><td colspan="' . count($props) . '">No entries yet.</td></tr>';
            $out[] = '}}';
            $out[] = '|}';
            $out[] = '';
        }

        return $out;
    }

    /* =====================================================================
     * PUBLIC: FULL TEMPLATE GENERATION ENTRYPOINT
     * ===================================================================== */

    public function generateAllTemplates( CategoryModel $category ): array {

        $errors = [];
        $name   = $category->getName();

        /* Category semantic template */
        try {
            $content = $this->generateSemanticTemplate( $category );
            $this->updateTemplate( $name . '/semantic', $content );
        } catch (\Exception $e) {
            $errors[] = "Error generating semantic template for $name: " . $e->getMessage();
        }

        /* Dispatcher template */
        try {
            $content = $this->generateDispatcherTemplate( $category );
            $this->updateTemplate( $name, $content );
        } catch (\Exception $e) {
            $errors[] = "Error generating dispatcher template for $name: " . $e->getMessage();
        }

        /* Subobject templates */
        $subs = array_unique(array_merge(
            $category->getRequiredSubgroups(),
            $category->getOptionalSubgroups()
        ));

        foreach ($subs as $subName) {
            try {
                $sub = $this->subobjectStore->readSubobject( $subName );
                if (!$sub instanceof SubobjectModel) {
                    $errors[] = "Missing subobject '$subName'";
                    continue;
                }

                /* semantic template */
                $content = $this->generateSubobjectTemplate( $sub );
                $this->updateTemplate( 'Subobject/' . $sub->getName(), $content );

                /* row template */
                $rowContent = $this->generateSubobjectRowTemplate( $sub );
                $this->updateTemplate( 'Subobject/' . $sub->getName() . '/row', $rowContent );

            } catch (\Exception $e) {
                $errors[] = "Error generating templates for subobject '$subName': " . $e->getMessage();
            }
        }

        return [
            'success' => empty($errors),
            'errors'  => $errors
        ];
    }

    /* =====================================================================
     * BASIC UPDATE WRAPPER
     * ===================================================================== */

    private function updateTemplate( string $name, string $content ): bool {
        if (trim($name) === '') {
            throw new \InvalidArgumentException("Template name cannot be empty");
        }

        $title = $this->pageCreator->makeTitle( $name, NS_TEMPLATE );
        if (!$title) {
            wfLogWarning("StructureSync: Failed to create Title for template '$name'");
            return false;
        }

        return $this->pageCreator->createOrUpdatePage(
            $title,
            $content,
            'StructureSync: Auto-generated template'
        );
    }

    /**
     * Check if the semantic template exists for a category.
     *
     * @param string $categoryName
     * @return bool
     */
    public function semanticTemplateExists( string $categoryName ): bool {
        $templateName = trim( $categoryName ) . '/semantic';
        $title = $this->pageCreator->makeTitle( $templateName, NS_TEMPLATE );
        return $title && $this->pageCreator->pageExists( $title );
    }
}
