<?php

namespace MediaWiki\Extension\StructureSync\Generator;

use MediaWiki\Extension\StructureSync\Schema\CategoryModel;
use MediaWiki\Extension\StructureSync\Store\PageCreator;
use MediaWiki\Extension\StructureSync\Schema\PropertyModel;
use MediaWiki\Extension\StructureSync\Util\NamingHelper;

/**
 * TemplateGenerator
 * -----------------
 * Generates two types of templates for each category:
 *   - Semantic templates   → Template:<Category>/semantic
 *   - Dispatcher templates → Template:<Category>
 *
 * Template Naming Conventions:
 * - Semantic: "Template:<CategoryName>/semantic"
 *   Stores SMW property values using {{#set:...}}
 * - Dispatcher: "Template:<CategoryName>"
 *   Coordinates semantic storage and display rendering
 *   Sets default form with {{#default_form:...}}
 * 
 * Architecture:
 * The three-template system (dispatcher, semantic, display) provides:
 * 1. Clean separation of concerns (data vs presentation)
 * 2. Allows display templates to be user-editable
 * 3. Enables automatic regeneration without breaking customizations
 * 
 * Template Flow:
 * Page → Dispatcher → Semantic (stores data) + Display (renders view)
 * 
 * Semantic templates store SMW data using #set.
 * Dispatcher templates wrap semantic + display templates.
 */
class TemplateGenerator
{

    /** @var PageCreator */
    private $pageCreator;

    /**
     * @param PageCreator|null $pageCreator
     */
    public function __construct(PageCreator $pageCreator = null)
    {
        $this->pageCreator = $pageCreator ?? new PageCreator();
    }

    /**
     * Sanitize a value to ensure MediaWiki never encounters null.
     *
     * @param string|null $value
     * @return string
     */
    private function sanitize(?string $value): string
    {
        return $value ?? '';
    }

    /* =====================================================================
     * SEMANTIC TEMPLATE
     * ===================================================================== */

    /**
     * Generate semantic template wikitext for a category.
     * 
     * Creates a template that stores all property values using SMW's {{#set:}}
     * parser function. Each property gets a parameter that maps to the SMW property.
     *
     * Output location:
     *   Template:<Category>/semantic
     * 
     * Generated structure:
     * - Noinclude header with metadata
     * - {{#set:...}} block with all properties
     * - Category annotation
     *
     * @param CategoryModel $category Effective (inherited) category
     * @return string Wikitext content for semantic template
     * @throws \InvalidArgumentException If category name is empty
     */
    public function generateSemanticTemplate(CategoryModel $category): string
    {
        if (trim($category->getName()) === '') {
            throw new \InvalidArgumentException('Category name cannot be empty');
        }

        $properties = $category->getAllProperties();
        
        // Note: Empty properties is valid - category might be purely organizational
        // or inherit all properties from parents
        
        sort($properties); // Deterministic output

        $lines = [];

        /* ------------------------------------------------------------------
         * NOINCLUDE HEADER
         * ------------------------------------------------------------------ */
        $lines[] = '<noinclude>';
        $lines[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
        $lines[] = '<!-- This semantic template stores SMW data for the category. -->';
        $lines[] = 'Semantic data template for [[Category:' . $this->sanitize($category->getName()) . ']].';
        $lines[] = '</noinclude><includeonly>';

        /* ------------------------------------------------------------------
         * SMW DATA (#set)
         * ------------------------------------------------------------------ */
        $lines[] = '{{#set:';

        foreach ($properties as $property) {
            $param = $this->sanitize($this->propertyToParameter($property));
            $propertySafe = $this->sanitize($property);
            $lines[] = ' | ' . $propertySafe . ' = {{{' . $param . '|}}}';
        }

        $lines[] = '}}';

        /* ------------------------------------------------------------------
         * Category annotation
         * ------------------------------------------------------------------ */
        $lines[] = '';
        $lines[] = '[[Category:' . $this->sanitize($category->getName()) . ']]';

        $lines[] = '</includeonly>';

        return implode("\n", $lines);
    }

    /* =====================================================================
     * DISPATCHER TEMPLATE
     * ===================================================================== */

    /**
     * Generate dispatcher template wikitext for the category.
     * 
     * The dispatcher is the main template that users transclude on pages.
     * It coordinates the semantic and display templates, ensuring both
     * data storage and presentation happen correctly.
     *
     * Output location:
     *   Template:<Category>
     *
     * Dispatcher template ensures:
     *   - Default form is set (for "edit with form" link)
     *   - Semantic template applied (stores data)
     *   - Display template applied (renders view)
     * 
     * Template parameters are passed through to both sub-templates.
     *
     * @param CategoryModel $category Effective (inherited) category
     * @return string Wikitext content for dispatcher template
     * @throws \InvalidArgumentException If category name is empty
     */
    public function generateDispatcherTemplate(CategoryModel $category): string
    {
        if (trim($category->getName()) === '') {
            throw new \InvalidArgumentException('Category name cannot be empty');
        }

        $properties = $category->getAllProperties();
        
        // Note: Empty properties is valid - category might be purely organizational
        // or inherit all properties from parents
        
        sort($properties);

        $name = $this->sanitize($category->getName());

        $lines = [];

        /* ------------------------------------------------------------------
         * NOINCLUDE
         * ------------------------------------------------------------------ */
        $lines[] = '<noinclude>';
        $lines[] = '<!-- AUTO-GENERATED by StructureSync - DO NOT EDIT MANUALLY -->';
        $lines[] = '<!-- This dispatcher template loads semantic + display templates. -->';
        $lines[] = 'Dispatcher for [[Category:' . $name . ']].';
        $lines[] = '* Semantic: [[Template:' . $name . '/semantic]]';
        $lines[] = '* Display:  [[Template:' . $name . '/display]]';
        $lines[] = '</noinclude><includeonly>';

        /* ------------------------------------------------------------------
         * DEFAULT FORM (for "edit with form" button)
         * ------------------------------------------------------------------ */
        $lines[] = '{{#default_form:' . $name . '}}';
        $lines[] = '';

        /* ------------------------------------------------------------------
         * SEMANTIC TEMPLATE INCLUDE
         * ------------------------------------------------------------------ */
        $lines[] = '{{' . $name . '/semantic';
        foreach ($properties as $property) {
            $param = $this->sanitize($this->propertyToParameter($property));
            $lines[] = ' | ' . $param . ' = {{{' . $param . '|}}}';
        }
        $lines[] = '}}';
        $lines[] = '';

        /* ------------------------------------------------------------------
         * DISPLAY TEMPLATE INCLUDE
         * ------------------------------------------------------------------ */

        $lines[] = '{{' . $name . '/display';
        foreach ($properties as $property) {
            $param = $this->sanitize($this->propertyToParameter($property));
            $lines[] = ' | ' . $param . ' = {{{' . $param . '|}}}';
        }
        $lines[] = '}}';

        $lines[] = '</includeonly>';

        return implode("\n", $lines);
    }


    /* =====================================================================
     * TEMPLATE CREATION / UPDATING
     * ===================================================================== */

    /**
     * Create or update a template page.
     * 
     * Handles the actual page creation/update operation with error handling.
     *
     * @param string $templateName  Name without namespace prefix
     * @param string $content Wikitext content
     * @return bool True on success, false on failure
     * @throws \InvalidArgumentException If template name is empty
     */
    public function updateTemplate(string $templateName, string $content): bool
    {
        if (trim($templateName) === '') {
            throw new \InvalidArgumentException('Template name cannot be empty');
        }

        $title = $this->pageCreator->makeTitle($templateName, NS_TEMPLATE);
        if (!$title) {
            wfLogWarning("StructureSync: Failed to create Title for template '$templateName'");
            return false;
        }

        $summary = 'StructureSync: Auto-generated template';
        $result = $this->pageCreator->createOrUpdatePage($title, $content, $summary);
        
        if (!$result) {
            wfLogWarning("StructureSync: Failed to save template '$templateName'");
        }
        
        return $result;
    }

    /**
     * Generate semantic + dispatcher templates for a category.
     * 
     * This is the main entry point for template generation. It creates both
     * templates in the correct order and reports any failures.
     * 
     * The operation continues even if one template fails, but reports all errors.
     *
     * @param CategoryModel $category Category to generate templates for
     * @return array{success:bool,errors:string[]} Result with overall success and error list
     */
    public function generateAllTemplates(CategoryModel $category): array
    {

        $result = ['success' => true, 'errors' => []];
        $name = $category->getName();

        try {
            /* --------------------------------------------------------------
             * SEMANTIC TEMPLATE
             * -------------------------------------------------------------- */
            $semantic = $this->generateSemanticTemplate($category);
            if (!$this->updateTemplate($name . '/semantic', $semantic)) {
                $result['success'] = false;
                $result['errors'][] = "Failed to create semantic template for $name";
            }
        } catch (\Exception $e) {
            $result['success'] = false;
            $result['errors'][] = "Error generating semantic template for $name: " . $e->getMessage();
        }

        try {
            /* --------------------------------------------------------------
             * DISPATCHER TEMPLATE
             * -------------------------------------------------------------- */
            $dispatcher = $this->generateDispatcherTemplate($category);
            if (!$this->updateTemplate($name, $dispatcher)) {
                $result['success'] = false;
                $result['errors'][] = "Failed to create dispatcher template for $name";
            }
        } catch (\Exception $e) {
            $result['success'] = false;
            $result['errors'][] = "Error generating dispatcher template for $name: " . $e->getMessage();
        }

        return $result;
    }

    /* =====================================================================
     * UTILITIES
     * ===================================================================== */

    /**
     * Convert SMW property names → PageForms parameter names.
     * 
     * Delegates to NamingHelper for consistent transformation across all generators.
     *
     * @param string $propertyName SMW property name
     * @return string Normalized parameter name
     */
    private function propertyToParameter(string $propertyName): string
    {
        return NamingHelper::propertyToParameter($propertyName);
    }

    /**
     * Check if semantic template exists.
     *
     * @param string $categoryName
     * @return bool
     */
    public function semanticTemplateExists(string $categoryName): bool
    {
        $title = $this->pageCreator->makeTitle($categoryName . '/semantic', NS_TEMPLATE);
        return $title && $this->pageCreator->pageExists($title);
    }

    /**
     * Check if dispatcher template exists.
     *
     * @param string $categoryName
     * @return bool
     */
    public function dispatcherTemplateExists(string $categoryName): bool
    {
        $title = $this->pageCreator->makeTitle($categoryName, NS_TEMPLATE);
        return $title && $this->pageCreator->pageExists($title);
    }
}
